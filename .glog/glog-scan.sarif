{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "glog-17c14b6e-ea66-4f79-b732-e1ae015d6eea",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other issues. These functions are often prohibited in secure coding standards. One such function is `fprintf`.\n\nThe `fprintf` function can lead to vulnerabilities if not used correctly. It can cause format string vulnerabilities if the format string is not a constant, or if it's a string that can be controlled by an attacker. This can lead to arbitrary code execution, crashes, or information leaks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `fprintf` and other similar functions that do not perform bounds checking. Instead, use safer alternatives that do perform bounds checking, such as `snprintf`. Always ensure that format strings are constants and cannot be controlled by an attacker.\n\n## Source Code Fix Recommendation\n\nReplace `fprintf` with `snprintf` as shown below:\n\n```cpp\n#include <cstdio>\n\n// Old vulnerable code\nvoid vulnerable_code(FILE* file, const char* data) {\n    fprintf(file, data);\n}\n\n// New secure code\nvoid secure_code(FILE* file, const char* data) {\n    char buffer[1024];\n    snprintf(buffer, sizeof(buffer), \"%s\", data);\n    fputs(buffer, file);\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `<cstdio>`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-9cbdc0c8-0b17-40eb-860e-a3fedc7ed33e",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises when the function is used without proper validation of the input string. If `strlen` is called on a pointer that does not point to a null-terminated string, it can lead to undefined behavior, including buffer overflows, crashes, or information leaks. This is because `strlen` continues to read memory until it encounters a null character, which can result in accessing memory beyond the intended buffer.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that all strings passed to `strlen` are properly null-terminated.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that automatically manage string lengths and memory, such as `std::string` in C++.\n3. **Bounds Checking**: Implement bounds checking to ensure that the string length does not exceed the buffer size.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential vulnerabilities related to string handling.\n\n### Source Code Fix Recommendation\n\nTo mitigate the vulnerability when using `strlen`, ensure that the input string is null-terminated and consider using `std::string` for safer string operations.\n\n```cpp\n#include <iostream>\n#include <string>\n\n// Original vulnerable function\nsize_t getSuffixLength(const char* suffix_) {\n    return strlen(suffix_);\n}\n\n// Fixed version using std::string\nsize_t getSuffixLength(const std::string& suffix) {\n    return suffix.length();\n}\n\nint main() {\n    std::string suffix = \"example\";\n    std::cout << \"Length of suffix: \" << getSuffixLength(suffix) << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the provided code example, the following standard library dependencies are required:\n\n- `<iostream>`: For input and output stream operations.\n- `<string>`: For using the `std::string` class.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-b0086ef9-f35a-4bfe-ab74-c0953f60a28a",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other issues. These functions are often prohibited in secure coding standards. One such function is `fprintf`.\n\nThe `fprintf` function can lead to vulnerabilities if not used correctly. It can cause format string vulnerabilities if the format string is not a constant, or if it's a string that can be controlled by an attacker. This can lead to arbitrary code execution, crashes, or information leaks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `fprintf` and other similar functions that do not perform bounds checking. Instead, use safer alternatives that do perform bounds checking, such as `snprintf`. Always ensure that format strings are constants and cannot be controlled by an attacker.\n\n## Source Code Fix Recommendation\n\nReplace `fprintf` with `snprintf` as shown below:\n\n```cpp\n#include <cstdio>\n\n// Old vulnerable code\nvoid vulnerable_code(FILE* file, const char* data) {\n    fprintf(file, data);\n}\n\n// New secure code\nvoid secure_code(FILE* file, const char* data) {\n    char buffer[1024];\n    snprintf(buffer, sizeof(buffer), \"%s\", data);\n    fputs(buffer, file);\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `<cstdio>`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-4b74496e-3ccd-4368-868d-dbbc936d7e8f",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other issues. These functions are often prohibited in secure coding standards. One such function is `fprintf`.\n\nThe `fprintf` function can lead to vulnerabilities if not used correctly. It can cause format string vulnerabilities if the format string is not a constant, or if it's a string that can be controlled by an attacker. This can lead to arbitrary code execution, crashes, or information leaks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `fprintf` and other similar functions that do not perform bounds checking. Instead, use safer alternatives that do perform bounds checking, such as `snprintf`. Always ensure that format strings are constants and cannot be controlled by an attacker.\n\n## Source Code Fix Recommendation\n\nReplace `fprintf` with `snprintf` as shown below:\n\n```cpp\n#include <cstdio>\n\n// Old vulnerable code\nvoid vulnerable_code(FILE* file, const char* data) {\n    fprintf(file, data);\n}\n\n// New secure code\nvoid secure_code(FILE* file, const char* data) {\n    char buffer[1024];\n    snprintf(buffer, sizeof(buffer), \"%s\", data);\n    fputs(buffer, file);\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `<cstdio>`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-7d8b12ef-3d91-42f0-bc3a-a9d16e9fea1e",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises from its inability to handle non-null-terminated strings. If `strlen` is called on a string that is not properly null-terminated, it can lead to undefined behavior, including buffer overflows, which can be exploited to execute arbitrary code or cause a program crash. This is particularly dangerous in scenarios where the string length is used to allocate memory or copy data.\n\n### General Mitigation Advice\n\n1. **Ensure Null-Termination**: Always ensure that strings are null-terminated before passing them to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions like `std::string` in C++ which manage null-termination automatically.\n3. **Input Validation**: Validate all input data to ensure it is within expected bounds and properly formatted.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential vulnerabilities in your code.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for strlen\n#include <string>  // Required for std::string\n\nvoid safeFunction(const char* funcName) {\n    if (funcName == nullptr) {\n        std::cerr << \"Error: Null pointer received.\" << std::endl;\n        return;\n    }\n\n    // Use std::string to ensure null-termination\n    std::string safeString(funcName);\n\n    // Now safeString is guaranteed to be null-terminated\n    size_t length = safeString.length();\n    std::cout << \"Length of the function name: \" << length << std::endl;\n}\n\nint main() {\n    const char* funcName = \"exampleFunction\";\n    safeFunction(funcName);\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output stream operations.\n- `<cstring>`: For C-style string operations, specifically `strlen`.\n- `<string>`: For using `std::string`, which provides safer string handling.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-134: Use of Externally-Controlled Format String](https://cwe.mitre.org/data/definitions/134.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-d9755b07-21ec-4f0e-b172-e15e089aa84d",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other issues. These functions are often prohibited in secure coding standards. One such function is `fprintf`.\n\nThe `fprintf` function can lead to vulnerabilities if not used correctly. It can cause format string vulnerabilities if the format string is not a constant, or if it's a string that can be controlled by an attacker. This can lead to arbitrary code execution, crashes, or information leaks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `fprintf` and other similar functions that do not perform bounds checking. Instead, use safer alternatives that do perform bounds checking, such as `snprintf`. Always ensure that format strings are constants and cannot be controlled by an attacker.\n\n## Source Code Fix Recommendation\n\nReplace `fprintf` with `snprintf` as shown below:\n\n```cpp\n#include <cstdio>\n\n// Old vulnerable code\nvoid vulnerable_code(FILE* file, const char* data) {\n    fprintf(file, data);\n}\n\n// New secure code\nvoid secure_code(FILE* file, const char* data) {\n    char buffer[1024];\n    snprintf(buffer, sizeof(buffer), \"%s\", data);\n    fputs(buffer, file);\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `<cstdio>`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-3db8901c-5cf5-4fec-b0c5-0413b0d55aed",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other issues. These functions are often prohibited in secure coding standards. One such function is `fprintf`.\n\nThe `fprintf` function can lead to vulnerabilities if not used correctly. It can cause format string vulnerabilities if the format string is not a constant, or if it's a string that can be controlled by an attacker. This can lead to arbitrary code execution, crashes, or information leaks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `fprintf` and other similar functions that do not perform bounds checking. Instead, use safer alternatives that do perform bounds checking, such as `snprintf`. Always ensure that format strings are constants and cannot be controlled by an attacker.\n\n## Source Code Fix Recommendation\n\nReplace `fprintf` with `snprintf` as shown below:\n\n```cpp\n#include <cstdio>\n\n// Old vulnerable code\nvoid vulnerable_code(FILE* file, const char* data) {\n    fprintf(file, data);\n}\n\n// New secure code\nvoid secure_code(FILE* file, const char* data) {\n    char buffer[1024];\n    snprintf(buffer, sizeof(buffer), \"%s\", data);\n    fputs(buffer, file);\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `<cstdio>`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-3ad6750d-581a-441f-bc3f-fd5d875ff97a",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. These functions are often prohibited in secure coding standards and should be avoided.\n\nIn this case, the `fopen` function is used, which can lead to vulnerabilities if not used correctly. The `fopen` function opens a file and returns a pointer to the file. If the file does not exist or cannot be found, the function returns a null pointer. This can lead to null pointer dereferencing if not handled correctly.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `fopen` such as `fopen_s` (in C11) or file stream objects in C++. These alternatives provide better error handling and are less prone to vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the `fopen` function with `fopen_s` or file stream objects. Here is an example of how to use `fopen_s`:\n\n```cpp\nFILE* fp = NULL;\nerrno_t err = fopen_s(&fp, \"file.txt\", \"r\");\nif (err != 0) {\n    // Handle error\n} else {\n    // Use file\n    fclose(fp);\n}\n```\n\nAnd here is an example of how to use file stream objects:\n\n```cpp\n#include <fstream>\n\nstd::ifstream file(\"file.txt\");\nif (!file) {\n    // Handle error\n} else {\n    // Use file\n    file.close();\n}\n```\n\n## Library Dependencies\n\nThe code examples above require the following library dependencies:\n\n- `<stdio.h>` or `<cstdio>` for `fopen_s`\n- `<fstream>` for file stream objects\n\n## References\n"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-150ed5ca-d8de-49a0-9409-a0faf7bd22e0",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other issues. These functions are often prohibited in secure coding standards. One such function is `fprintf`.\n\nThe `fprintf` function can lead to vulnerabilities if not used correctly. It can cause format string vulnerabilities if the format string is not a constant, or if it's a string that can be controlled by an attacker. This can lead to arbitrary code execution, crashes, or information leaks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `fprintf` and other similar functions that do not perform bounds checking. Instead, use safer alternatives that do perform bounds checking, such as `snprintf`. Always ensure that format strings are constants and cannot be controlled by an attacker.\n\n## Source Code Fix Recommendation\n\nReplace `fprintf` with `snprintf` as shown below:\n\n```cpp\n#include <cstdio>\n\n// Old vulnerable code\nvoid vulnerable_code(FILE* file, const char* data) {\n    fprintf(file, data);\n}\n\n// New secure code\nvoid secure_code(FILE* file, const char* data) {\n    char buffer[1024];\n    snprintf(buffer, sizeof(buffer), \"%s\", data);\n    fputs(buffer, file);\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `<cstdio>`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-601b03cf-3e19-4ca8-ae41-abc365dbfbf2",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected C Function Prohibited\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other types of security issues. One such function is `printf`.\n\nThe `printf` function is a common function in C programming for output formatting. However, it can lead to vulnerabilities if not used correctly. For instance, if user-supplied data is passed directly to `printf` as the format string, it can lead to a format string vulnerability, which can allow an attacker to read or write to arbitrary memory, leading to information disclosure or code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` and similar functions with variable format strings. Instead, use safer alternatives that do not allow for format string vulnerabilities, such as `puts` or `fputs` for simple string output. If formatted output is necessary, ensure that the format string is a constant and not user-supplied data.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_supplied_string;\n// ...\nprintf(user_supplied_string);\n```\n\nUse:\n\n```cpp\nchar* user_supplied_string;\n// ...\nputs(user_supplied_string);\n```\n\nOr:\n\n```cpp\nchar* user_supplied_string;\n// ...\nfputs(user_supplied_string, stdout);\n```\n\n## Library Dependencies\n\nThe code examples above require the C standard library, which is typically included with `#include <stdio.h>`.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-ca795548-4f6b-4528-9296-5974165f64ac",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected C Function Prohibited\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other types of security issues. One such function is `printf`.\n\nThe `printf` function is a common function in C programming for output formatting. However, it can lead to vulnerabilities if not used correctly. For instance, if user-supplied data is passed directly to `printf` as the format string, it can lead to a format string vulnerability, which can allow an attacker to read or write to arbitrary memory, leading to information disclosure or code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` and similar functions with variable format strings. Instead, use safer alternatives that do not allow for format string vulnerabilities, such as `puts` or `fputs` for simple string output. If formatted output is necessary, ensure that the format string is a constant and not user-supplied data.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_supplied_string;\n// ...\nprintf(user_supplied_string);\n```\n\nUse:\n\n```cpp\nchar* user_supplied_string;\n// ...\nputs(user_supplied_string);\n```\n\nOr:\n\n```cpp\nchar* user_supplied_string;\n// ...\nfputs(user_supplied_string, stdout);\n```\n\n## Library Dependencies\n\nThe code examples above require the C standard library, which is typically included with `#include <stdio.h>`.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-5d6f7bb0-0895-4790-8d2f-11e6e2267bb4",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other issues. These functions are often prohibited in secure coding standards. One such function is `fprintf`.\n\nThe `fprintf` function can lead to vulnerabilities if not used correctly. It can cause format string vulnerabilities if the format string is not a constant, or if it's a string that can be controlled by an attacker. This can lead to arbitrary code execution, crashes, or information leaks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `fprintf` and other similar functions that do not perform bounds checking. Instead, use safer alternatives that do perform bounds checking, such as `snprintf`. Always ensure that format strings are constants and cannot be controlled by an attacker.\n\n## Source Code Fix Recommendation\n\nReplace `fprintf` with `snprintf` as shown below:\n\n```cpp\n#include <cstdio>\n\n// Old vulnerable code\nvoid vulnerable_code(FILE* file, const char* data) {\n    fprintf(file, data);\n}\n\n// New secure code\nvoid secure_code(FILE* file, const char* data) {\n    char buffer[1024];\n    snprintf(buffer, sizeof(buffer), \"%s\", data);\n    fputs(buffer, file);\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `<cstdio>`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-2c684bd2-7397-49f9-99ea-eba24066b671",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other issues. These functions are often prohibited in secure coding standards. One such function is `fprintf`.\n\nThe `fprintf` function can lead to vulnerabilities if not used correctly. It can cause format string vulnerabilities if the format string is not a constant, or if it's a string that can be controlled by an attacker. This can lead to arbitrary code execution, crashes, or information leaks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `fprintf` and other similar functions that do not perform bounds checking. Instead, use safer alternatives that do perform bounds checking, such as `snprintf`. Always ensure that format strings are constants and cannot be controlled by an attacker.\n\n## Source Code Fix Recommendation\n\nReplace `fprintf` with `snprintf` as shown below:\n\n```cpp\n#include <cstdio>\n\n// Old vulnerable code\nvoid vulnerable_code(FILE* file, const char* data) {\n    fprintf(file, data);\n}\n\n// New secure code\nvoid secure_code(FILE* file, const char* data) {\n    char buffer[1024];\n    snprintf(buffer, sizeof(buffer), \"%s\", data);\n    fputs(buffer, file);\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `<cstdio>`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-07d92295-9f2e-464b-855e-2ba2b506b31c",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-bf911ed7-bb82-414d-a7c0-a98b971e0eb6",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-03e3286f-1c48-49e1-ab3f-6f161d7b9b89",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-5eb721b7-0ad3-4141-ba9d-09cbf9882eb6",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-167c27f1-d1a2-4b58-a17c-091aff425e98",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-c359dd80-15a4-4591-87b6-c36f22eb62a5",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-042c6638-4a8a-4aee-9e57-3d933fe288b0",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other issues. These functions are often prohibited in secure coding standards. One such function is `fprintf`.\n\nThe `fprintf` function can lead to vulnerabilities if not used correctly. It can cause format string vulnerabilities if the format string is not a constant, or if it's a string that can be controlled by an attacker. This can lead to arbitrary code execution, crashes, or information leaks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `fprintf` and other similar functions that do not perform bounds checking. Instead, use safer alternatives that do perform bounds checking, such as `snprintf`. Always ensure that format strings are constants and cannot be controlled by an attacker.\n\n## Source Code Fix Recommendation\n\nReplace `fprintf` with `snprintf` as shown below:\n\n```cpp\n#include <cstdio>\n\n// Old vulnerable code\nvoid vulnerable_code(FILE* file, const char* data) {\n    fprintf(file, data);\n}\n\n// New secure code\nvoid secure_code(FILE* file, const char* data) {\n    char buffer[1024];\n    snprintf(buffer, sizeof(buffer), \"%s\", data);\n    fputs(buffer, file);\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `<cstdio>`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-492ad4a3-32e2-467f-a661-89e9c9b6ce6e",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected C Function Prohibited\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other types of security issues. One such function is `printf`.\n\nThe `printf` function is a common function in C programming for output formatting. However, it can lead to vulnerabilities if not used correctly. For instance, if user-supplied data is passed directly to `printf` as the format string, it can lead to a format string vulnerability, which can allow an attacker to read or write to arbitrary memory, leading to information disclosure or code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` and similar functions with variable format strings. Instead, use safer alternatives that do not allow for format string vulnerabilities, such as `puts` or `fputs` for simple string output. If formatted output is necessary, ensure that the format string is a constant and not user-supplied data.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_supplied_string;\n// ...\nprintf(user_supplied_string);\n```\n\nUse:\n\n```cpp\nchar* user_supplied_string;\n// ...\nputs(user_supplied_string);\n```\n\nOr:\n\n```cpp\nchar* user_supplied_string;\n// ...\nfputs(user_supplied_string, stdout);\n```\n\n## Library Dependencies\n\nThe code examples above require the C standard library, which is typically included with `#include <stdio.h>`.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-5caf50e3-e17b-402f-b3ec-d3239ef7790f",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-894ce6f7-9681-42eb-9c72-358e401fbce3",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected C Function Prohibited\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other types of security issues. One such function is `printf`.\n\nThe `printf` function is a common function in C programming for output formatting. However, it can lead to vulnerabilities if not used correctly. For instance, if user-supplied data is passed directly to `printf` as the format string, it can lead to a format string vulnerability, which can allow an attacker to read or write to arbitrary memory, leading to information disclosure or code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` and similar functions with variable format strings. Instead, use safer alternatives that do not allow for format string vulnerabilities, such as `puts` or `fputs` for simple string output. If formatted output is necessary, ensure that the format string is a constant and not user-supplied data.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_supplied_string;\n// ...\nprintf(user_supplied_string);\n```\n\nUse:\n\n```cpp\nchar* user_supplied_string;\n// ...\nputs(user_supplied_string);\n```\n\nOr:\n\n```cpp\nchar* user_supplied_string;\n// ...\nfputs(user_supplied_string, stdout);\n```\n\n## Library Dependencies\n\nThe code examples above require the C standard library, which is typically included with `#include <stdio.h>`.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-38abd51b-8bb3-4bfc-bf62-8836447eb19d",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-636e6e56-2566-4542-8714-5fe967967bb3",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other issues. These functions are often prohibited in secure coding standards. One such function is `fprintf`.\n\nThe `fprintf` function can lead to vulnerabilities if not used correctly. It can cause format string vulnerabilities if the format string is not a constant, or if it's a string that can be controlled by an attacker. This can lead to arbitrary code execution, crashes, or information leaks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `fprintf` and other similar functions that do not perform bounds checking. Instead, use safer alternatives that do perform bounds checking, such as `snprintf`. Always ensure that format strings are constants and cannot be controlled by an attacker.\n\n## Source Code Fix Recommendation\n\nReplace `fprintf` with `snprintf` as shown below:\n\n```cpp\n#include <cstdio>\n\n// Old vulnerable code\nvoid vulnerable_code(FILE* file, const char* data) {\n    fprintf(file, data);\n}\n\n// New secure code\nvoid secure_code(FILE* file, const char* data) {\n    char buffer[1024];\n    snprintf(buffer, sizeof(buffer), \"%s\", data);\n    fputs(buffer, file);\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `<cstdio>`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-4d399260-df19-41cd-9d17-16f52d337244",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected C Function Prohibited\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other types of security issues. One such function is `printf`.\n\nThe `printf` function is a common function in C programming for output formatting. However, it can lead to vulnerabilities if not used correctly. For instance, if user-supplied data is passed directly to `printf` as the format string, it can lead to a format string vulnerability, which can allow an attacker to read or write to arbitrary memory, leading to information disclosure or code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` and similar functions with variable format strings. Instead, use safer alternatives that do not allow for format string vulnerabilities, such as `puts` or `fputs` for simple string output. If formatted output is necessary, ensure that the format string is a constant and not user-supplied data.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_supplied_string;\n// ...\nprintf(user_supplied_string);\n```\n\nUse:\n\n```cpp\nchar* user_supplied_string;\n// ...\nputs(user_supplied_string);\n```\n\nOr:\n\n```cpp\nchar* user_supplied_string;\n// ...\nfputs(user_supplied_string, stdout);\n```\n\n## Library Dependencies\n\nThe code examples above require the C standard library, which is typically included with `#include <stdio.h>`.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-189e9745-7801-4b54-b368-714eb06c1984",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-1cac75f2-57b5-49b2-bfad-e74fa963292d",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected C Function Prohibited\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other types of security issues. One such function is `printf`.\n\nThe `printf` function is a common function in C programming for output formatting. However, it can lead to vulnerabilities if not used correctly. For instance, if user-supplied data is passed directly to `printf` as the format string, it can lead to a format string vulnerability, which can allow an attacker to read or write to arbitrary memory, leading to information disclosure or code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` and similar functions with variable format strings. Instead, use safer alternatives that do not allow for format string vulnerabilities, such as `puts` or `fputs` for simple string output. If formatted output is necessary, ensure that the format string is a constant and not user-supplied data.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_supplied_string;\n// ...\nprintf(user_supplied_string);\n```\n\nUse:\n\n```cpp\nchar* user_supplied_string;\n// ...\nputs(user_supplied_string);\n```\n\nOr:\n\n```cpp\nchar* user_supplied_string;\n// ...\nfputs(user_supplied_string, stdout);\n```\n\n## Library Dependencies\n\nThe code examples above require the C standard library, which is typically included with `#include <stdio.h>`.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-dd0da790-0bb7-4e0f-a95d-876d13fffd5b",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Vulnerable/Compromised Hash Algorithm\" vulnerability in C++ refers to the use of cryptographic hash functions that are considered weak or compromised, such as SHA-1. SHA-1 is no longer considered secure due to vulnerabilities that allow for collision attacks, where two different inputs produce the same hash output. This can lead to security breaches, such as data integrity violations and unauthorized data access.\n\n### General Mitigation Advice\n\n- **Use Stronger Hash Functions**: Replace SHA-1 with more secure hash functions like SHA-256 or SHA-3.\n- **Regularly Update Cryptographic Libraries**: Ensure that cryptographic libraries are up-to-date to benefit from the latest security improvements.\n- **Conduct Security Audits**: Regularly audit your codebase for the use of deprecated or weak cryptographic algorithms.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace SHA-1 with SHA-256 using the OpenSSL library in C++.\n\n```cpp\n#include <openssl/sha.h>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n\n// Function to compute SHA-256 hash\nstd::string computeSHA256(const std::string& input) {\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    SHA256_CTX sha256;\n    SHA256_Init(&sha256);\n    SHA256_Update(&sha256, input.c_str(), input.size());\n    SHA256_Final(hash, &sha256);\n\n    std::stringstream ss;\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n    return ss.str();\n}\n\nint main() {\n    std::string data = \"example data\";\n    std::string hash = computeSHA256(data);\n    std::cout << \"SHA-256 hash: \" << hash << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, you need the following library:\n\n- OpenSSL\n\nEnsure that OpenSSL is installed and properly linked during compilation. You can compile the code using:\n\n```bash\ng++ -o hash_example hash_example.cpp -lssl -lcrypto\n```\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "glog-cfc00688-6ef4-4a58-b622-cd01133c7957",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected C Function Prohibited\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other types of security issues. One such function is `printf`.\n\nThe `printf` function is a common function in C programming for output formatting. However, it can lead to vulnerabilities if not used correctly. For instance, if user-supplied data is passed directly to `printf` as the format string, it can lead to a format string vulnerability, which can allow an attacker to read or write to arbitrary memory, leading to information disclosure or code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` and similar functions with variable format strings. Instead, use safer alternatives that do not allow for format string vulnerabilities, such as `puts` or `fputs` for simple string output. If formatted output is necessary, ensure that the format string is a constant and not user-supplied data.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_supplied_string;\n// ...\nprintf(user_supplied_string);\n```\n\nUse:\n\n```cpp\nchar* user_supplied_string;\n// ...\nputs(user_supplied_string);\n```\n\nOr:\n\n```cpp\nchar* user_supplied_string;\n// ...\nfputs(user_supplied_string, stdout);\n```\n\n## Library Dependencies\n\nThe code examples above require the C standard library, which is typically included with `#include <stdio.h>`.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-295a35ef-f221-463b-b677-a1ec9a39cc2d",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other issues. These functions are often prohibited in secure coding standards. One such function is `fprintf`.\n\nThe `fprintf` function can lead to vulnerabilities if not used correctly. It can cause format string vulnerabilities if the format string is not a constant, or if it's a string that can be controlled by an attacker. This can lead to arbitrary code execution, crashes, or information leaks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `fprintf` and other similar functions that do not perform bounds checking. Instead, use safer alternatives that do perform bounds checking, such as `snprintf`. Always ensure that format strings are constants and cannot be controlled by an attacker.\n\n## Source Code Fix Recommendation\n\nReplace `fprintf` with `snprintf` as shown below:\n\n```cpp\n#include <cstdio>\n\n// Old vulnerable code\nvoid vulnerable_code(FILE* file, const char* data) {\n    fprintf(file, data);\n}\n\n// New secure code\nvoid secure_code(FILE* file, const char* data) {\n    char buffer[1024];\n    snprintf(buffer, sizeof(buffer), \"%s\", data);\n    fputs(buffer, file);\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `<cstdio>`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-775275e5-2400-42fb-ba21-367e4293f854",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Vulnerable/Compromised Hash Algorithm\" vulnerability in C++ refers to the use of cryptographic hash functions that are considered weak or compromised, such as SHA-1. SHA-1 is no longer considered secure due to vulnerabilities that allow for collision attacks, where two different inputs produce the same hash output. This can lead to security breaches, such as data integrity violations and unauthorized data access.\n\n### General Mitigation Advice\n\n- **Use Stronger Hash Functions**: Replace SHA-1 with more secure hash functions like SHA-256 or SHA-3.\n- **Regularly Update Cryptographic Libraries**: Ensure that cryptographic libraries are up-to-date to benefit from the latest security improvements.\n- **Conduct Security Audits**: Regularly audit your codebase for the use of deprecated or weak cryptographic algorithms.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace SHA-1 with SHA-256 using the OpenSSL library in C++.\n\n```cpp\n#include <openssl/sha.h>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n\n// Function to compute SHA-256 hash\nstd::string computeSHA256(const std::string& input) {\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    SHA256_CTX sha256;\n    SHA256_Init(&sha256);\n    SHA256_Update(&sha256, input.c_str(), input.size());\n    SHA256_Final(hash, &sha256);\n\n    std::stringstream ss;\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n    return ss.str();\n}\n\nint main() {\n    std::string data = \"example data\";\n    std::string hash = computeSHA256(data);\n    std::cout << \"SHA-256 hash: \" << hash << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, you need the following library:\n\n- OpenSSL\n\nEnsure that OpenSSL is installed and properly linked during compilation. You can compile the code using:\n\n```bash\ng++ -o hash_example hash_example.cpp -lssl -lcrypto\n```\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "glog-79425fd9-f3fa-4812-8313-3dcb181f7cea",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Vulnerable/Compromised Hash Algorithm\" vulnerability in C++ refers to the use of cryptographic hash functions that are considered weak or compromised, such as SHA-1. SHA-1 is no longer considered secure due to vulnerabilities that allow for collision attacks, where two different inputs produce the same hash output. This can lead to security breaches, such as data integrity violations and unauthorized data access.\n\n### General Mitigation Advice\n\n- **Use Stronger Hash Functions**: Replace SHA-1 with more secure hash functions like SHA-256 or SHA-3.\n- **Regularly Update Cryptographic Libraries**: Ensure that cryptographic libraries are up-to-date to benefit from the latest security improvements.\n- **Conduct Security Audits**: Regularly audit your codebase for the use of deprecated or weak cryptographic algorithms.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace SHA-1 with SHA-256 using the OpenSSL library in C++.\n\n```cpp\n#include <openssl/sha.h>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n\n// Function to compute SHA-256 hash\nstd::string computeSHA256(const std::string& input) {\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    SHA256_CTX sha256;\n    SHA256_Init(&sha256);\n    SHA256_Update(&sha256, input.c_str(), input.size());\n    SHA256_Final(hash, &sha256);\n\n    std::stringstream ss;\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n    return ss.str();\n}\n\nint main() {\n    std::string data = \"example data\";\n    std::string hash = computeSHA256(data);\n    std::cout << \"SHA-256 hash: \" << hash << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, you need the following library:\n\n- OpenSSL\n\nEnsure that OpenSSL is installed and properly linked during compilation. You can compile the code using:\n\n```bash\ng++ -o hash_example hash_example.cpp -lssl -lcrypto\n```\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "glog-9b234118-42da-44e6-bf0f-305c51f4daa1",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected C Function Prohibited\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other types of security issues. One such function is `printf`.\n\nThe `printf` function is a common function in C programming for output formatting. However, it can lead to vulnerabilities if not used correctly. For instance, if user-supplied data is passed directly to `printf` as the format string, it can lead to a format string vulnerability, which can allow an attacker to read or write to arbitrary memory, leading to information disclosure or code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` and similar functions with variable format strings. Instead, use safer alternatives that do not allow for format string vulnerabilities, such as `puts` or `fputs` for simple string output. If formatted output is necessary, ensure that the format string is a constant and not user-supplied data.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_supplied_string;\n// ...\nprintf(user_supplied_string);\n```\n\nUse:\n\n```cpp\nchar* user_supplied_string;\n// ...\nputs(user_supplied_string);\n```\n\nOr:\n\n```cpp\nchar* user_supplied_string;\n// ...\nfputs(user_supplied_string, stdout);\n```\n\n## Library Dependencies\n\nThe code examples above require the C standard library, which is typically included with `#include <stdio.h>`.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-754c6576-8c10-43c3-9f79-05e44aded80f",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected C Function Prohibited\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other types of security issues. One such function is `printf`.\n\nThe `printf` function is a common function in C programming for output formatting. However, it can lead to vulnerabilities if not used correctly. For instance, if user-supplied data is passed directly to `printf` as the format string, it can lead to a format string vulnerability, which can allow an attacker to read or write to arbitrary memory, leading to information disclosure or code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` and similar functions with variable format strings. Instead, use safer alternatives that do not allow for format string vulnerabilities, such as `puts` or `fputs` for simple string output. If formatted output is necessary, ensure that the format string is a constant and not user-supplied data.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_supplied_string;\n// ...\nprintf(user_supplied_string);\n```\n\nUse:\n\n```cpp\nchar* user_supplied_string;\n// ...\nputs(user_supplied_string);\n```\n\nOr:\n\n```cpp\nchar* user_supplied_string;\n// ...\nfputs(user_supplied_string, stdout);\n```\n\n## Library Dependencies\n\nThe code examples above require the C standard library, which is typically included with `#include <stdio.h>`.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-5d07d9bc-17d7-494c-91f4-25ce39a32492",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Vulnerable/Compromised Hash Algorithm\" vulnerability in C++ refers to the use of cryptographic hash functions that are considered weak or compromised, such as SHA-1. SHA-1 is no longer considered secure due to vulnerabilities that allow for collision attacks, where two different inputs produce the same hash output. This can lead to security breaches, such as data integrity violations and unauthorized data access.\n\n### General Mitigation Advice\n\n- **Use Stronger Hash Functions**: Replace SHA-1 with more secure hash functions like SHA-256 or SHA-3.\n- **Regularly Update Cryptographic Libraries**: Ensure that cryptographic libraries are up-to-date to benefit from the latest security improvements.\n- **Conduct Security Audits**: Regularly audit your codebase for the use of deprecated or weak cryptographic algorithms.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace SHA-1 with SHA-256 using the OpenSSL library in C++.\n\n```cpp\n#include <openssl/sha.h>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n\n// Function to compute SHA-256 hash\nstd::string computeSHA256(const std::string& input) {\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    SHA256_CTX sha256;\n    SHA256_Init(&sha256);\n    SHA256_Update(&sha256, input.c_str(), input.size());\n    SHA256_Final(hash, &sha256);\n\n    std::stringstream ss;\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n    return ss.str();\n}\n\nint main() {\n    std::string data = \"example data\";\n    std::string hash = computeSHA256(data);\n    std::cout << \"SHA-256 hash: \" << hash << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, you need the following library:\n\n- OpenSSL\n\nEnsure that OpenSSL is installed and properly linked during compilation. You can compile the code using:\n\n```bash\ng++ -o hash_example hash_example.cpp -lssl -lcrypto\n```\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "glog-b2cb9f17-1111-4167-989a-dd482cab4ffd",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected C Function Prohibited\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other types of security issues. One such function is `printf`.\n\nThe `printf` function is a common function in C programming for output formatting. However, it can lead to vulnerabilities if not used correctly. For instance, if user-supplied data is passed directly to `printf` as the format string, it can lead to a format string vulnerability, which can allow an attacker to read or write to arbitrary memory, leading to information disclosure or code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` and similar functions with variable format strings. Instead, use safer alternatives that do not allow for format string vulnerabilities, such as `puts` or `fputs` for simple string output. If formatted output is necessary, ensure that the format string is a constant and not user-supplied data.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_supplied_string;\n// ...\nprintf(user_supplied_string);\n```\n\nUse:\n\n```cpp\nchar* user_supplied_string;\n// ...\nputs(user_supplied_string);\n```\n\nOr:\n\n```cpp\nchar* user_supplied_string;\n// ...\nfputs(user_supplied_string, stdout);\n```\n\n## Library Dependencies\n\nThe code examples above require the C standard library, which is typically included with `#include <stdio.h>`.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-3e50c5eb-6f1d-4384-a03c-5dfa5b251e16",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected C Function Prohibited\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other types of security issues. One such function is `printf`.\n\nThe `printf` function is a common function in C programming for output formatting. However, it can lead to vulnerabilities if not used correctly. For instance, if user-supplied data is passed directly to `printf` as the format string, it can lead to a format string vulnerability, which can allow an attacker to read or write to arbitrary memory, leading to information disclosure or code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` and similar functions with variable format strings. Instead, use safer alternatives that do not allow for format string vulnerabilities, such as `puts` or `fputs` for simple string output. If formatted output is necessary, ensure that the format string is a constant and not user-supplied data.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_supplied_string;\n// ...\nprintf(user_supplied_string);\n```\n\nUse:\n\n```cpp\nchar* user_supplied_string;\n// ...\nputs(user_supplied_string);\n```\n\nOr:\n\n```cpp\nchar* user_supplied_string;\n// ...\nfputs(user_supplied_string, stdout);\n```\n\n## Library Dependencies\n\nThe code examples above require the C standard library, which is typically included with `#include <stdio.h>`.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-88aa85cb-ff57-44b9-a33a-98d4c1aa8941",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected C Function Prohibited\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other types of security issues. One such function is `printf`.\n\nThe `printf` function is a common function in C programming for output formatting. However, it can lead to vulnerabilities if not used correctly. For instance, if user-supplied data is passed directly to `printf` as the format string, it can lead to a format string vulnerability, which can allow an attacker to read or write to arbitrary memory, leading to information disclosure or code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` and similar functions with variable format strings. Instead, use safer alternatives that do not allow for format string vulnerabilities, such as `puts` or `fputs` for simple string output. If formatted output is necessary, ensure that the format string is a constant and not user-supplied data.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_supplied_string;\n// ...\nprintf(user_supplied_string);\n```\n\nUse:\n\n```cpp\nchar* user_supplied_string;\n// ...\nputs(user_supplied_string);\n```\n\nOr:\n\n```cpp\nchar* user_supplied_string;\n// ...\nfputs(user_supplied_string, stdout);\n```\n\n## Library Dependencies\n\nThe code examples above require the C standard library, which is typically included with `#include <stdio.h>`.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-c457f927-12b0-4b50-b205-11fd210ca24d",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected C Function Prohibited\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other types of security issues. One such function is `printf`.\n\nThe `printf` function is a common function in C programming for output formatting. However, it can lead to vulnerabilities if not used correctly. For instance, if user-supplied data is passed directly to `printf` as the format string, it can lead to a format string vulnerability, which can allow an attacker to read or write to arbitrary memory, leading to information disclosure or code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` and similar functions with variable format strings. Instead, use safer alternatives that do not allow for format string vulnerabilities, such as `puts` or `fputs` for simple string output. If formatted output is necessary, ensure that the format string is a constant and not user-supplied data.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_supplied_string;\n// ...\nprintf(user_supplied_string);\n```\n\nUse:\n\n```cpp\nchar* user_supplied_string;\n// ...\nputs(user_supplied_string);\n```\n\nOr:\n\n```cpp\nchar* user_supplied_string;\n// ...\nfputs(user_supplied_string, stdout);\n```\n\n## Library Dependencies\n\nThe code examples above require the C standard library, which is typically included with `#include <stdio.h>`.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-e528ff3e-e333-400e-8de5-f887f14689ae",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected C Function Prohibited\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other types of security issues. One such function is `printf`.\n\nThe `printf` function is a common function in C programming for output formatting. However, it can lead to vulnerabilities if not used correctly. For instance, if user-supplied data is passed directly to `printf` as the format string, it can lead to a format string vulnerability, which can allow an attacker to read or write to arbitrary memory, leading to information disclosure or code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` and similar functions with variable format strings. Instead, use safer alternatives that do not allow for format string vulnerabilities, such as `puts` or `fputs` for simple string output. If formatted output is necessary, ensure that the format string is a constant and not user-supplied data.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_supplied_string;\n// ...\nprintf(user_supplied_string);\n```\n\nUse:\n\n```cpp\nchar* user_supplied_string;\n// ...\nputs(user_supplied_string);\n```\n\nOr:\n\n```cpp\nchar* user_supplied_string;\n// ...\nfputs(user_supplied_string, stdout);\n```\n\n## Library Dependencies\n\nThe code examples above require the C standard library, which is typically included with `#include <stdio.h>`.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-772ae528-357a-4f00-9096-ec1454f8540b",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected C Function Prohibited\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other types of security issues. One such function is `printf`.\n\nThe `printf` function is a common function in C programming for output formatting. However, it can lead to vulnerabilities if not used correctly. For instance, if user-supplied data is passed directly to `printf` as the format string, it can lead to a format string vulnerability, which can allow an attacker to read or write to arbitrary memory, leading to information disclosure or code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` and similar functions with variable format strings. Instead, use safer alternatives that do not allow for format string vulnerabilities, such as `puts` or `fputs` for simple string output. If formatted output is necessary, ensure that the format string is a constant and not user-supplied data.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_supplied_string;\n// ...\nprintf(user_supplied_string);\n```\n\nUse:\n\n```cpp\nchar* user_supplied_string;\n// ...\nputs(user_supplied_string);\n```\n\nOr:\n\n```cpp\nchar* user_supplied_string;\n// ...\nfputs(user_supplied_string, stdout);\n```\n\n## Library Dependencies\n\nThe code examples above require the C standard library, which is typically included with `#include <stdio.h>`.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-83476265-fbdc-483f-9e42-89057908dffa",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected C Function Prohibited\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other types of security issues. One such function is `printf`.\n\nThe `printf` function is a common function in C programming for output formatting. However, it can lead to vulnerabilities if not used correctly. For instance, if user-supplied data is passed directly to `printf` as the format string, it can lead to a format string vulnerability, which can allow an attacker to read or write to arbitrary memory, leading to information disclosure or code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` and similar functions with variable format strings. Instead, use safer alternatives that do not allow for format string vulnerabilities, such as `puts` or `fputs` for simple string output. If formatted output is necessary, ensure that the format string is a constant and not user-supplied data.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_supplied_string;\n// ...\nprintf(user_supplied_string);\n```\n\nUse:\n\n```cpp\nchar* user_supplied_string;\n// ...\nputs(user_supplied_string);\n```\n\nOr:\n\n```cpp\nchar* user_supplied_string;\n// ...\nfputs(user_supplied_string, stdout);\n```\n\n## Library Dependencies\n\nThe code examples above require the C standard library, which is typically included with `#include <stdio.h>`.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-76b37440-f09f-47fc-9a61-027b09306d6f",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected C Function Prohibited\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other types of security issues. One such function is `printf`.\n\nThe `printf` function is a common function in C programming for output formatting. However, it can lead to vulnerabilities if not used correctly. For instance, if user-supplied data is passed directly to `printf` as the format string, it can lead to a format string vulnerability, which can allow an attacker to read or write to arbitrary memory, leading to information disclosure or code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` and similar functions with variable format strings. Instead, use safer alternatives that do not allow for format string vulnerabilities, such as `puts` or `fputs` for simple string output. If formatted output is necessary, ensure that the format string is a constant and not user-supplied data.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_supplied_string;\n// ...\nprintf(user_supplied_string);\n```\n\nUse:\n\n```cpp\nchar* user_supplied_string;\n// ...\nputs(user_supplied_string);\n```\n\nOr:\n\n```cpp\nchar* user_supplied_string;\n// ...\nfputs(user_supplied_string, stdout);\n```\n\n## Library Dependencies\n\nThe code examples above require the C standard library, which is typically included with `#include <stdio.h>`.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-27812892-05c9-406e-9df6-46cd2452917f",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-d5ae64ab-4b9c-42c8-bbcc-9d4e47f6bccc",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-ecbbdb1b-84ed-4dea-9641-9a4bb3188cf5",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-0183d426-fa9a-4b93-8732-82a145ba47db",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected C Function Prohibited\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other types of security issues. One such function is `printf`.\n\nThe `printf` function is a common function in C programming for output formatting. However, it can lead to vulnerabilities if not used correctly. For instance, if user-supplied data is passed directly to `printf` as the format string, it can lead to a format string vulnerability, which can allow an attacker to read or write to arbitrary memory, leading to information disclosure or code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` and similar functions with variable format strings. Instead, use safer alternatives that do not allow for format string vulnerabilities, such as `puts` or `fputs` for simple string output. If formatted output is necessary, ensure that the format string is a constant and not user-supplied data.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_supplied_string;\n// ...\nprintf(user_supplied_string);\n```\n\nUse:\n\n```cpp\nchar* user_supplied_string;\n// ...\nputs(user_supplied_string);\n```\n\nOr:\n\n```cpp\nchar* user_supplied_string;\n// ...\nfputs(user_supplied_string, stdout);\n```\n\n## Library Dependencies\n\nThe code examples above require the C standard library, which is typically included with `#include <stdio.h>`.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-83b859a4-9123-4f10-ae66-1faae262bacc",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected C Function Prohibited\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other types of security issues. One such function is `printf`.\n\nThe `printf` function is a common function in C programming for output formatting. However, it can lead to vulnerabilities if not used correctly. For instance, if user-supplied data is passed directly to `printf` as the format string, it can lead to a format string vulnerability, which can allow an attacker to read or write to arbitrary memory, leading to information disclosure or code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` and similar functions with variable format strings. Instead, use safer alternatives that do not allow for format string vulnerabilities, such as `puts` or `fputs` for simple string output. If formatted output is necessary, ensure that the format string is a constant and not user-supplied data.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_supplied_string;\n// ...\nprintf(user_supplied_string);\n```\n\nUse:\n\n```cpp\nchar* user_supplied_string;\n// ...\nputs(user_supplied_string);\n```\n\nOr:\n\n```cpp\nchar* user_supplied_string;\n// ...\nfputs(user_supplied_string, stdout);\n```\n\n## Library Dependencies\n\nThe code examples above require the C standard library, which is typically included with `#include <stdio.h>`.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-89493fc8-68e9-4faf-804b-2c40a88a48a4",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ typically arises from improper use of the `malloc` function, which is used to allocate memory dynamically. The specific issue in the provided code snippet is the use of `malloc(sizeof(aocl_post_op_bias))`. This can lead to vulnerabilities such as buffer overflows or memory corruption if the size of the allocated memory does not match the actual size needed for the data structure or if the memory is not properly managed (e.g., not freed after use).\n\n### General Mitigation Advice\n\n1. **Use `new` in C++**: Prefer using `new` and `delete` in C++ for dynamic memory allocation and deallocation, as they are type-safe and automatically call constructors and destructors.\n2. **Check for Allocation Failure**: Always check if the memory allocation was successful by verifying that the returned pointer is not `NULL`.\n3. **Free Allocated Memory**: Ensure that all dynamically allocated memory is freed when it is no longer needed to prevent memory leaks.\n4. **Use Smart Pointers**: Consider using smart pointers like `std::unique_ptr` or `std::shared_ptr` to manage dynamic memory automatically.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <memory> // For std::unique_ptr\n\n// Assuming aocl_post_op_bias is a struct or class\nstruct aocl_post_op_bias {\n    // Members of the struct\n};\n\nint main() {\n    // Use smart pointer for automatic memory management\n    std::unique_ptr<aocl_post_op_bias> biasPtr = std::make_unique<aocl_post_op_bias>();\n\n    // Use the object as needed\n    // ...\n\n    // No need to manually free memory, smart pointer will handle it\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<memory>`: Required for using smart pointers like `std::unique_ptr`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-34d00e9f-a366-4594-ab51-0f85dbf79d38",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ typically arises from improper use of the `malloc` function, which is used to allocate memory dynamically. The specific issue with `malloc(sizeof(aocl_post_op_eltwise))` is that it may not correctly allocate the intended amount of memory if `aocl_post_op_eltwise` is a pointer or an incomplete type. This can lead to buffer overflows, memory corruption, or undefined behavior.\n\n### General Mitigation Advice\n\n1. **Use `sizeof` Correctly**: Ensure that `sizeof` is used on the correct type. If `aocl_post_op_eltwise` is a pointer, use the dereferenced type.\n2. **Check for NULL**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Use `new` in C++**: Prefer using `new` and `delete` in C++ for memory management, as they are type-safe and call constructors/destructors.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib> // for malloc and free\n#include <iostream>\n\n// Assuming aocl_post_op_eltwise is a struct or class\nstruct aocl_post_op_eltwise {\n    // member variables\n};\n\nint main() {\n    // Correct usage of sizeof with the actual type\n    aocl_post_op_eltwise* ptr = (aocl_post_op_eltwise*)malloc(sizeof(aocl_post_op_eltwise));\n    \n    if (ptr == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n\n    // Free the allocated memory\n    free(ptr);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<iostream>`: Required for input/output operations.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-5110c4bb-d689-41a5-ae16-bca755ae020d",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ typically arises from improper use of the `malloc` function, which is used to allocate memory dynamically. The specific vulnerability in the code snippet `malloc((nthr_n - 1))` is due to the allocation of insufficient memory. The expression `(nthr_n - 1)` suggests that only a single byte is being allocated, which is likely insufficient for the intended use, especially if the memory is meant to store more complex data types or arrays.\n\n### General Mitigation Advice\n\n1. **Ensure Adequate Memory Allocation**: Always allocate enough memory to accommodate the data type or structure you intend to store. Consider the size of the data type when using `malloc`.\n\n2. **Check for NULL Pointers**: After calling `malloc`, always check if the returned pointer is `NULL`, which indicates that the memory allocation failed.\n\n3. **Use Safer Alternatives**: Consider using `new` in C++ for memory allocation, which throws an exception on failure, or use smart pointers like `std::unique_ptr` or `std::shared_ptr` to manage memory automatically.\n\n4. **Free Allocated Memory**: Ensure that any dynamically allocated memory is properly freed using `free` to prevent memory leaks.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib> // Required for malloc and free\n#include <iostream>\n\nint main() {\n    size_t nthr_n = 10; // Example value\n    size_t element_size = sizeof(int); // Example data type\n\n    // Corrected memory allocation\n    int* array = (int*)malloc((nthr_n - 1) * element_size);\n\n    if (array == NULL) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n    for (size_t i = 0; i < nthr_n - 1; ++i) {\n        array[i] = i;\n    }\n\n    // Free the allocated memory\n    free(array);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<iostream>`: Required for input and output operations.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-105930c4-2103-4ae3-af3d-ec9f63c49cbd",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected C Function Prohibited\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other types of security issues. One such function is `printf`.\n\nThe `printf` function is a common function in C programming for output formatting. However, it can lead to vulnerabilities if not used correctly. For instance, if user-supplied data is passed directly to `printf` as the format string, it can lead to a format string vulnerability, which can allow an attacker to read or write to arbitrary memory, leading to information disclosure or code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` and similar functions with variable format strings. Instead, use safer alternatives that do not allow for format string vulnerabilities, such as `puts` or `fputs` for simple string output. If formatted output is necessary, ensure that the format string is a constant and not user-supplied data.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_supplied_string;\n// ...\nprintf(user_supplied_string);\n```\n\nUse:\n\n```cpp\nchar* user_supplied_string;\n// ...\nputs(user_supplied_string);\n```\n\nOr:\n\n```cpp\nchar* user_supplied_string;\n// ...\nfputs(user_supplied_string, stdout);\n```\n\n## Library Dependencies\n\nThe code examples above require the C standard library, which is typically included with `#include <stdio.h>`.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-02939ac4-37af-4416-9df0-3a8cb7894347",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other issues. These functions are often prohibited in secure coding standards.\n\nThe `getenv` function is one such function. It is used to retrieve the value of an environment variable from the process environment. The problem with `getenv` is that it returns a pointer to a string that may be overwritten by subsequent calls to `getenv`, `setenv`, or `unsetenv`. This can lead to race conditions if the application is multithreaded.\n\n## Mitigation Advice\n\nAvoid using `getenv` in multithreaded applications. If you need to use environment variables, consider copying the values into your own buffers to avoid race conditions.\n\n## Source Code Fix Recommendation\n\nInstead of using `getenv`, you can use `secure_getenv` if it's available on your platform. `secure_getenv` behaves the same as `getenv` but returns NULL if the process is being run with elevated privileges. This can help prevent privilege escalation attacks.\n\nHere's an example of how you can use `secure_getenv`:\n\n```cpp\n#include <stdlib.h>\n\nconst char* value = secure_getenv(\"MY_VARIABLE\");\nif (value != NULL) {\n    // Use the value\n} else {\n    // Handle the error\n}\n```\n\n## Library Dependencies\n\nThe `getenv` and `secure_getenv` functions are part of the C standard library, so you don't need any additional libraries to use them.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-dd7d4390-0a3e-4dfe-9134-791da741aa1f",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Vulnerable/Compromised Hash Algorithm\" vulnerability in C++ refers to the use of cryptographic hash functions that are considered weak or broken, such as MD2. MD2 is an older hash function that is no longer considered secure due to its susceptibility to collision attacks, where two different inputs produce the same hash output. This vulnerability can lead to security issues such as data integrity violations and unauthorized data access.\n\n### General Mitigation Advice\n\n1. **Avoid Using Weak Hash Functions**: Replace MD2 with a more secure hash function like SHA-256 or SHA-3.\n2. **Use Well-Maintained Libraries**: Utilize cryptographic libraries that are actively maintained and updated.\n3. **Regularly Update Dependencies**: Ensure that all cryptographic libraries are up-to-date to benefit from the latest security patches.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace MD2 with SHA-256 using the OpenSSL library in C++.\n\n```cpp\n#include <openssl/sha.h>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n\n// Function to compute SHA-256 hash\nstd::string computeSHA256(const std::string& data) {\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    SHA256_CTX sha256;\n    SHA256_Init(&sha256);\n    SHA256_Update(&sha256, data.c_str(), data.size());\n    SHA256_Final(hash, &sha256);\n\n    std::stringstream ss;\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n    return ss.str();\n}\n\nint main() {\n    std::string data = \"example data\";\n    std::string hash = computeSHA256(data);\n    std::cout << \"SHA-256 hash: \" << hash << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, you need the following library:\n\n- OpenSSL\n\nEnsure that OpenSSL is installed on your system and linked during compilation. You can compile the code using:\n\n```bash\ng++ -o hash_example hash_example.cpp -lssl -lcrypto\n```\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "glog-889637e8-3184-4563-9bb6-e20a84f34832",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, leading to potential memory allocation issues. Specifically, using `malloc(sizeof(aocl_post_op))` can be problematic if `aocl_post_op` is a type rather than an instance, as `sizeof` will return the size of the type, which may not be the intended size for allocation. This can lead to buffer overflows, memory corruption, or undefined behavior if the allocated memory is not sufficient for the intended use.\n\n### General Mitigation Advice\n\n1. **Use `sizeof` Correctly**: Ensure that `sizeof` is used with an instance of the type or the type itself, depending on the context.\n2. **Check Return Values**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Use Safer Alternatives**: Consider using `new` in C++ for memory allocation, which provides type safety and automatically calls constructors.\n4. **Initialize Allocated Memory**: Use functions like `calloc` or explicitly initialize memory to avoid using uninitialized memory.\n5. **Free Allocated Memory**: Ensure that all dynamically allocated memory is freed to prevent memory leaks.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib> // Required for malloc and free\n\n// Assuming aocl_post_op is a type\nstruct aocl_post_op {\n    // Members of the struct\n};\n\nint main() {\n    // Correct usage of malloc with sizeof\n    aocl_post_op* post_op = (aocl_post_op*)malloc(sizeof(aocl_post_op));\n    if (post_op == nullptr) {\n        // Handle allocation failure\n        return -1;\n    }\n\n    // Use the allocated memory\n\n    // Free the allocated memory\n    free(post_op);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstdlib>`: This library is required for using `malloc` and `free`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-f4e3f452-8aee-40a9-b052-edab7a0f64bb",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ typically arises from improper use of the `malloc` function, which is used to allocate memory dynamically. This can lead to several issues, such as buffer overflows, memory leaks, or undefined behavior if the allocated memory is not managed correctly. In the provided code snippet, the vulnerability may occur if `max_post_ops_seq_length` is not properly validated, leading to an incorrect or excessive amount of memory being allocated.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that `max_post_ops_seq_length` is validated to be within a reasonable range before using it in `malloc`.\n2. **Check for NULL**: Always check if `malloc` returns `NULL`, which indicates that the memory allocation failed.\n3. **Free Allocated Memory**: Ensure that any memory allocated with `malloc` is properly freed using `free` to prevent memory leaks.\n4. **Use Safer Alternatives**: Consider using safer alternatives like `calloc`, which initializes the allocated memory to zero, or C++ constructs like `std::vector` that manage memory automatically.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstdlib> // for malloc and free\n\n#define MAX_POST_OPS_SEQ_LENGTH 1000 // Define a reasonable maximum\n\ntypedef int AOCL_POST_OP_TYPE; // Example type definition\n\nint main() {\n    size_t max_post_ops_seq_length = 10; // Example value, should be validated\n\n    // Validate max_post_ops_seq_length\n    if (max_post_ops_seq_length > MAX_POST_OPS_SEQ_LENGTH) {\n        std::cerr << \"Error: max_post_ops_seq_length is too large.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    // Allocate memory\n    AOCL_POST_OP_TYPE* post_ops = (AOCL_POST_OP_TYPE*)malloc(max_post_ops_seq_length * sizeof(AOCL_POST_OP_TYPE));\n    \n    // Check if malloc succeeded\n    if (post_ops == NULL) {\n        std::cerr << \"Error: Memory allocation failed.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    // Use the allocated memory\n    // ...\n\n    // Free the allocated memory\n    free(post_ops);\n\n    return EXIT_SUCCESS;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<cstdlib>`: For `malloc` and `free` functions.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-08ac7fc1-b2ad-424e-8e01-0ec660078ab5",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other issues. These functions are often prohibited in secure coding standards.\n\nThe `getenv` function is one such function. It is used to retrieve the value of an environment variable from the process environment. The problem with `getenv` is that it returns a pointer to a string that may be overwritten by subsequent calls to `getenv`, `setenv`, or `unsetenv`. This can lead to race conditions if the application is multithreaded.\n\n## Mitigation Advice\n\nAvoid using `getenv` in multithreaded applications. If you need to use environment variables, consider copying the values into your own buffers to avoid race conditions.\n\n## Source Code Fix Recommendation\n\nInstead of using `getenv`, you can use `secure_getenv` if it's available on your platform. `secure_getenv` behaves the same as `getenv` but returns NULL if the process is being run with elevated privileges. This can help prevent privilege escalation attacks.\n\nHere's an example of how you can use `secure_getenv`:\n\n```cpp\n#include <stdlib.h>\n\nconst char* value = secure_getenv(\"MY_VARIABLE\");\nif (value != NULL) {\n    // Use the value\n} else {\n    // Handle the error\n}\n```\n\n## Library Dependencies\n\nThe `getenv` and `secure_getenv` functions are part of the C standard library, so you don't need any additional libraries to use them.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-2719d534-7d61-4f56-b784-bba857d5eb87",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Vulnerable/Compromised Hash Algorithm\" vulnerability in C++ refers to the use of cryptographic hash functions that are considered weak or broken, such as MD2. MD2 is an older hash function that is no longer considered secure due to its susceptibility to collision attacks, where two different inputs produce the same hash output. This vulnerability can lead to security issues such as data integrity violations and unauthorized data access.\n\n### General Mitigation Advice\n\n1. **Avoid Using Weak Hash Functions**: Replace MD2 with a more secure hash function like SHA-256 or SHA-3.\n2. **Use Well-Maintained Libraries**: Utilize cryptographic libraries that are actively maintained and updated.\n3. **Regularly Update Dependencies**: Ensure that all cryptographic libraries are up-to-date to benefit from the latest security patches.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace MD2 with SHA-256 using the OpenSSL library in C++.\n\n```cpp\n#include <openssl/sha.h>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n\n// Function to compute SHA-256 hash\nstd::string computeSHA256(const std::string& data) {\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    SHA256_CTX sha256;\n    SHA256_Init(&sha256);\n    SHA256_Update(&sha256, data.c_str(), data.size());\n    SHA256_Final(hash, &sha256);\n\n    std::stringstream ss;\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n    return ss.str();\n}\n\nint main() {\n    std::string data = \"example data\";\n    std::string hash = computeSHA256(data);\n    std::cout << \"SHA-256 hash: \" << hash << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, you need the following library:\n\n- OpenSSL\n\nEnsure that OpenSSL is installed on your system and linked during compilation. You can compile the code using:\n\n```bash\ng++ -o hash_example hash_example.cpp -lssl -lcrypto\n```\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "glog-8d9c5495-a7ad-4b03-9e93-d3cbd52840b0",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Vulnerable/Compromised Hash Algorithm\" vulnerability in C++ refers to the use of cryptographic hash functions that are considered weak or broken, such as MD2. MD2 is an older hash function that is no longer considered secure due to its susceptibility to collision attacks, where two different inputs produce the same hash output. This vulnerability can lead to security issues such as data integrity violations and unauthorized data access.\n\n### General Mitigation Advice\n\n1. **Avoid Using Weak Hash Functions**: Replace MD2 with a more secure hash function like SHA-256 or SHA-3.\n2. **Use Well-Maintained Libraries**: Utilize cryptographic libraries that are actively maintained and updated.\n3. **Regularly Update Dependencies**: Ensure that all cryptographic libraries are up-to-date to benefit from the latest security patches.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace MD2 with SHA-256 using the OpenSSL library in C++.\n\n```cpp\n#include <openssl/sha.h>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n\n// Function to compute SHA-256 hash\nstd::string computeSHA256(const std::string& data) {\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    SHA256_CTX sha256;\n    SHA256_Init(&sha256);\n    SHA256_Update(&sha256, data.c_str(), data.size());\n    SHA256_Final(hash, &sha256);\n\n    std::stringstream ss;\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n    return ss.str();\n}\n\nint main() {\n    std::string data = \"example data\";\n    std::string hash = computeSHA256(data);\n    std::cout << \"SHA-256 hash: \" << hash << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, you need the following library:\n\n- OpenSSL\n\nEnsure that OpenSSL is installed on your system and linked during compilation. You can compile the code using:\n\n```bash\ng++ -o hash_example hash_example.cpp -lssl -lcrypto\n```\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "glog-b7697e46-cc72-4a1b-9442-99778ea87ba0",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Vulnerable/Compromised Hash Algorithm\" vulnerability in C++ refers to the use of cryptographic hash functions that are considered weak or broken, such as MD2. MD2 is an older hash function that is no longer considered secure due to its susceptibility to collision attacks, where two different inputs produce the same hash output. This vulnerability can lead to security issues such as data integrity violations and unauthorized data access.\n\n### General Mitigation Advice\n\n1. **Avoid Using Weak Hash Functions**: Replace MD2 with a more secure hash function like SHA-256 or SHA-3.\n2. **Use Well-Maintained Libraries**: Utilize cryptographic libraries that are actively maintained and updated.\n3. **Regularly Update Dependencies**: Ensure that all cryptographic libraries are up-to-date to benefit from the latest security patches.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace MD2 with SHA-256 using the OpenSSL library in C++.\n\n```cpp\n#include <openssl/sha.h>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n\n// Function to compute SHA-256 hash\nstd::string computeSHA256(const std::string& data) {\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    SHA256_CTX sha256;\n    SHA256_Init(&sha256);\n    SHA256_Update(&sha256, data.c_str(), data.size());\n    SHA256_Final(hash, &sha256);\n\n    std::stringstream ss;\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n    return ss.str();\n}\n\nint main() {\n    std::string data = \"example data\";\n    std::string hash = computeSHA256(data);\n    std::cout << \"SHA-256 hash: \" << hash << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, you need the following library:\n\n- OpenSSL\n\nEnsure that OpenSSL is installed on your system and linked during compilation. You can compile the code using:\n\n```bash\ng++ -o hash_example hash_example.cpp -lssl -lcrypto\n```\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "glog-f449af1b-56b0-4530-8fdc-385dcac7cb2c",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Vulnerable/Compromised Hash Algorithm\" vulnerability in C++ refers to the use of cryptographic hash functions that are considered weak or broken, such as MD2. MD2 is an older hash function that is no longer considered secure due to its susceptibility to collision attacks, where two different inputs produce the same hash output. This vulnerability can lead to security issues such as data integrity violations and unauthorized data access.\n\n### General Mitigation Advice\n\n1. **Avoid Using Weak Hash Functions**: Replace MD2 with a more secure hash function like SHA-256 or SHA-3.\n2. **Use Well-Maintained Libraries**: Utilize cryptographic libraries that are actively maintained and updated.\n3. **Regularly Update Dependencies**: Ensure that all cryptographic libraries are up-to-date to benefit from the latest security patches.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace MD2 with SHA-256 using the OpenSSL library in C++.\n\n```cpp\n#include <openssl/sha.h>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n\n// Function to compute SHA-256 hash\nstd::string computeSHA256(const std::string& data) {\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    SHA256_CTX sha256;\n    SHA256_Init(&sha256);\n    SHA256_Update(&sha256, data.c_str(), data.size());\n    SHA256_Final(hash, &sha256);\n\n    std::stringstream ss;\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n    return ss.str();\n}\n\nint main() {\n    std::string data = \"example data\";\n    std::string hash = computeSHA256(data);\n    std::cout << \"SHA-256 hash: \" << hash << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, you need the following library:\n\n- OpenSSL\n\nEnsure that OpenSSL is installed on your system and linked during compilation. You can compile the code using:\n\n```bash\ng++ -o hash_example hash_example.cpp -lssl -lcrypto\n```\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "glog-43d0f931-b8a6-44af-805c-80e21a788f08",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Vulnerable/Compromised Hash Algorithm\" vulnerability in C++ refers to the use of cryptographic hash functions that are considered weak or broken, such as MD2. MD2 is an older hash function that is no longer considered secure due to its susceptibility to collision attacks, where two different inputs produce the same hash output. This vulnerability can lead to security issues such as data integrity violations and unauthorized data access.\n\n### General Mitigation Advice\n\n1. **Avoid Using Weak Hash Functions**: Replace MD2 with a more secure hash function like SHA-256 or SHA-3.\n2. **Use Well-Maintained Libraries**: Utilize cryptographic libraries that are actively maintained and updated.\n3. **Regularly Update Dependencies**: Ensure that all cryptographic libraries are up-to-date to benefit from the latest security patches.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace MD2 with SHA-256 using the OpenSSL library in C++.\n\n```cpp\n#include <openssl/sha.h>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n\n// Function to compute SHA-256 hash\nstd::string computeSHA256(const std::string& data) {\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    SHA256_CTX sha256;\n    SHA256_Init(&sha256);\n    SHA256_Update(&sha256, data.c_str(), data.size());\n    SHA256_Final(hash, &sha256);\n\n    std::stringstream ss;\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n    return ss.str();\n}\n\nint main() {\n    std::string data = \"example data\";\n    std::string hash = computeSHA256(data);\n    std::cout << \"SHA-256 hash: \" << hash << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, you need the following library:\n\n- OpenSSL\n\nEnsure that OpenSSL is installed on your system and linked during compilation. You can compile the code using:\n\n```bash\ng++ -o hash_example hash_example.cpp -lssl -lcrypto\n```\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "glog-b47d5f90-4271-4486-aca7-a9e408d7fd97",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Vulnerable/Compromised Hash Algorithm\" vulnerability in C++ refers to the use of cryptographic hash functions that are considered weak or broken, such as MD2. MD2 is an older hash function that is no longer considered secure due to its susceptibility to collision attacks, where two different inputs produce the same hash output. This vulnerability can lead to security issues such as data integrity violations and unauthorized data access.\n\n### General Mitigation Advice\n\n1. **Avoid Using Weak Hash Functions**: Replace MD2 with a more secure hash function like SHA-256 or SHA-3.\n2. **Use Well-Maintained Libraries**: Utilize cryptographic libraries that are actively maintained and updated.\n3. **Regularly Update Dependencies**: Ensure that all cryptographic libraries are up-to-date to benefit from the latest security patches.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace MD2 with SHA-256 using the OpenSSL library in C++.\n\n```cpp\n#include <openssl/sha.h>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n\n// Function to compute SHA-256 hash\nstd::string computeSHA256(const std::string& data) {\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    SHA256_CTX sha256;\n    SHA256_Init(&sha256);\n    SHA256_Update(&sha256, data.c_str(), data.size());\n    SHA256_Final(hash, &sha256);\n\n    std::stringstream ss;\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n    return ss.str();\n}\n\nint main() {\n    std::string data = \"example data\";\n    std::string hash = computeSHA256(data);\n    std::cout << \"SHA-256 hash: \" << hash << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, you need the following library:\n\n- OpenSSL\n\nEnsure that OpenSSL is installed on your system and linked during compilation. You can compile the code using:\n\n```bash\ng++ -o hash_example hash_example.cpp -lssl -lcrypto\n```\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "glog-c069335a-1ef0-4ad3-81f0-1552f82dd91e",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Vulnerable/Compromised Hash Algorithm\" vulnerability in C++ refers to the use of cryptographic hash functions that are considered weak or broken, such as MD2. MD2 is an older hash function that is no longer considered secure due to its susceptibility to collision attacks, where two different inputs produce the same hash output. This vulnerability can lead to security issues such as data integrity violations and unauthorized data access.\n\n### General Mitigation Advice\n\n1. **Avoid Using Weak Hash Functions**: Replace MD2 with a more secure hash function like SHA-256 or SHA-3.\n2. **Use Well-Maintained Libraries**: Utilize cryptographic libraries that are actively maintained and updated.\n3. **Regularly Update Dependencies**: Ensure that all cryptographic libraries are up-to-date to benefit from the latest security patches.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace MD2 with SHA-256 using the OpenSSL library in C++.\n\n```cpp\n#include <openssl/sha.h>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n\n// Function to compute SHA-256 hash\nstd::string computeSHA256(const std::string& data) {\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    SHA256_CTX sha256;\n    SHA256_Init(&sha256);\n    SHA256_Update(&sha256, data.c_str(), data.size());\n    SHA256_Final(hash, &sha256);\n\n    std::stringstream ss;\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n    return ss.str();\n}\n\nint main() {\n    std::string data = \"example data\";\n    std::string hash = computeSHA256(data);\n    std::cout << \"SHA-256 hash: \" << hash << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, you need the following library:\n\n- OpenSSL\n\nEnsure that OpenSSL is installed on your system and linked during compilation. You can compile the code using:\n\n```bash\ng++ -o hash_example hash_example.cpp -lssl -lcrypto\n```\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "glog-6c6d0c65-eb2f-47a6-9c17-48034400e231",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Vulnerable/Compromised Hash Algorithm\" vulnerability in C++ refers to the use of cryptographic hash functions that are considered weak or broken, such as MD2. MD2 is an older hash function that is no longer considered secure due to its susceptibility to collision attacks, where two different inputs produce the same hash output. This vulnerability can lead to security issues such as data integrity violations and unauthorized data access.\n\n### General Mitigation Advice\n\n1. **Avoid Using Weak Hash Functions**: Replace MD2 with a more secure hash function like SHA-256 or SHA-3.\n2. **Use Well-Maintained Libraries**: Utilize cryptographic libraries that are actively maintained and updated.\n3. **Regularly Update Dependencies**: Ensure that all cryptographic libraries are up-to-date to benefit from the latest security patches.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace MD2 with SHA-256 using the OpenSSL library in C++.\n\n```cpp\n#include <openssl/sha.h>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n\n// Function to compute SHA-256 hash\nstd::string computeSHA256(const std::string& data) {\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    SHA256_CTX sha256;\n    SHA256_Init(&sha256);\n    SHA256_Update(&sha256, data.c_str(), data.size());\n    SHA256_Final(hash, &sha256);\n\n    std::stringstream ss;\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n    return ss.str();\n}\n\nint main() {\n    std::string data = \"example data\";\n    std::string hash = computeSHA256(data);\n    std::cout << \"SHA-256 hash: \" << hash << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, you need the following library:\n\n- OpenSSL\n\nEnsure that OpenSSL is installed on your system and linked during compilation. You can compile the code using:\n\n```bash\ng++ -o hash_example hash_example.cpp -lssl -lcrypto\n```\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "glog-fa0e94cf-f547-4dee-810a-cd6e3166af61",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Vulnerable/Compromised Hash Algorithm\" vulnerability in C++ refers to the use of cryptographic hash functions that are considered weak or broken, such as MD2. MD2 is an older hash function that is no longer considered secure due to its susceptibility to collision attacks, where two different inputs produce the same hash output. This vulnerability can lead to security issues such as data integrity violations and unauthorized data access.\n\n### General Mitigation Advice\n\n1. **Avoid Using Weak Hash Functions**: Replace MD2 with a more secure hash function like SHA-256 or SHA-3.\n2. **Use Well-Maintained Libraries**: Utilize cryptographic libraries that are actively maintained and updated.\n3. **Regularly Update Dependencies**: Ensure that all cryptographic libraries are up-to-date to benefit from the latest security patches.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace MD2 with SHA-256 using the OpenSSL library in C++.\n\n```cpp\n#include <openssl/sha.h>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n\n// Function to compute SHA-256 hash\nstd::string computeSHA256(const std::string& data) {\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    SHA256_CTX sha256;\n    SHA256_Init(&sha256);\n    SHA256_Update(&sha256, data.c_str(), data.size());\n    SHA256_Final(hash, &sha256);\n\n    std::stringstream ss;\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n    return ss.str();\n}\n\nint main() {\n    std::string data = \"example data\";\n    std::string hash = computeSHA256(data);\n    std::cout << \"SHA-256 hash: \" << hash << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, you need the following library:\n\n- OpenSSL\n\nEnsure that OpenSSL is installed on your system and linked during compilation. You can compile the code using:\n\n```bash\ng++ -o hash_example hash_example.cpp -lssl -lcrypto\n```\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "glog-9dd27b01-8c46-4c67-a7d9-8635269003b2",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Vulnerable/Compromised Hash Algorithm\" vulnerability in C++ refers to the use of cryptographic hash functions that are considered weak or broken, such as MD2. MD2 is an older hash function that is no longer considered secure due to its susceptibility to collision attacks, where two different inputs produce the same hash output. This vulnerability can lead to security issues such as data integrity violations and unauthorized data access.\n\n### General Mitigation Advice\n\n1. **Avoid Using Weak Hash Functions**: Replace MD2 with a more secure hash function like SHA-256 or SHA-3.\n2. **Use Well-Maintained Libraries**: Utilize cryptographic libraries that are actively maintained and updated.\n3. **Regularly Update Dependencies**: Ensure that all cryptographic libraries are up-to-date to benefit from the latest security patches.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace MD2 with SHA-256 using the OpenSSL library in C++.\n\n```cpp\n#include <openssl/sha.h>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n\n// Function to compute SHA-256 hash\nstd::string computeSHA256(const std::string& data) {\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    SHA256_CTX sha256;\n    SHA256_Init(&sha256);\n    SHA256_Update(&sha256, data.c_str(), data.size());\n    SHA256_Final(hash, &sha256);\n\n    std::stringstream ss;\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n    return ss.str();\n}\n\nint main() {\n    std::string data = \"example data\";\n    std::string hash = computeSHA256(data);\n    std::cout << \"SHA-256 hash: \" << hash << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, you need the following library:\n\n- OpenSSL\n\nEnsure that OpenSSL is installed on your system and linked during compilation. You can compile the code using:\n\n```bash\ng++ -o hash_example hash_example.cpp -lssl -lcrypto\n```\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "glog-54e13457-710e-4f2d-ba7a-3106a4dd5de5",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Vulnerable/Compromised Hash Algorithm\" vulnerability in C++ refers to the use of cryptographic hash functions that are considered weak or broken, such as MD2. MD2 is an older hash function that is no longer considered secure due to its susceptibility to collision attacks, where two different inputs produce the same hash output. This vulnerability can lead to security issues such as data integrity violations and unauthorized data access.\n\n### General Mitigation Advice\n\n1. **Avoid Using Weak Hash Functions**: Replace MD2 with a more secure hash function like SHA-256 or SHA-3.\n2. **Use Well-Maintained Libraries**: Utilize cryptographic libraries that are actively maintained and updated.\n3. **Regularly Update Dependencies**: Ensure that all cryptographic libraries are up-to-date to benefit from the latest security patches.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace MD2 with SHA-256 using the OpenSSL library in C++.\n\n```cpp\n#include <openssl/sha.h>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n\n// Function to compute SHA-256 hash\nstd::string computeSHA256(const std::string& data) {\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    SHA256_CTX sha256;\n    SHA256_Init(&sha256);\n    SHA256_Update(&sha256, data.c_str(), data.size());\n    SHA256_Final(hash, &sha256);\n\n    std::stringstream ss;\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n    return ss.str();\n}\n\nint main() {\n    std::string data = \"example data\";\n    std::string hash = computeSHA256(data);\n    std::cout << \"SHA-256 hash: \" << hash << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, you need the following library:\n\n- OpenSSL\n\nEnsure that OpenSSL is installed on your system and linked during compilation. You can compile the code using:\n\n```bash\ng++ -o hash_example hash_example.cpp -lssl -lcrypto\n```\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "glog-6c51da51-2f09-4e69-8805-1596cb4c9032",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Vulnerable/Compromised Hash Algorithm\" vulnerability in C++ refers to the use of cryptographic hash functions that are considered weak or broken, such as MD2. MD2 is an older hash function that is no longer considered secure due to its susceptibility to collision attacks, where two different inputs produce the same hash output. This vulnerability can lead to security issues such as data integrity violations and unauthorized data access.\n\n### General Mitigation Advice\n\n1. **Avoid Using Weak Hash Functions**: Replace MD2 with a more secure hash function like SHA-256 or SHA-3.\n2. **Use Well-Maintained Libraries**: Utilize cryptographic libraries that are actively maintained and updated.\n3. **Regularly Update Dependencies**: Ensure that all cryptographic libraries are up-to-date to benefit from the latest security patches.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace MD2 with SHA-256 using the OpenSSL library in C++.\n\n```cpp\n#include <openssl/sha.h>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n\n// Function to compute SHA-256 hash\nstd::string computeSHA256(const std::string& data) {\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    SHA256_CTX sha256;\n    SHA256_Init(&sha256);\n    SHA256_Update(&sha256, data.c_str(), data.size());\n    SHA256_Final(hash, &sha256);\n\n    std::stringstream ss;\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n    return ss.str();\n}\n\nint main() {\n    std::string data = \"example data\";\n    std::string hash = computeSHA256(data);\n    std::cout << \"SHA-256 hash: \" << hash << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, you need the following library:\n\n- OpenSSL\n\nEnsure that OpenSSL is installed on your system and linked during compilation. You can compile the code using:\n\n```bash\ng++ -o hash_example hash_example.cpp -lssl -lcrypto\n```\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "glog-af634f68-8e85-4691-b63b-2c68228a4292",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Vulnerable/Compromised Hash Algorithm\" vulnerability in C++ refers to the use of cryptographic hash functions that are considered weak or broken, such as MD2. MD2 is an older hash function that is no longer considered secure due to its susceptibility to collision attacks, where two different inputs produce the same hash output. This vulnerability can lead to security issues such as data integrity violations and unauthorized data access.\n\n### General Mitigation Advice\n\n1. **Avoid Using Weak Hash Functions**: Replace MD2 with a more secure hash function like SHA-256 or SHA-3.\n2. **Use Well-Maintained Libraries**: Utilize cryptographic libraries that are actively maintained and updated.\n3. **Regularly Update Dependencies**: Ensure that all cryptographic libraries are up-to-date to benefit from the latest security patches.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace MD2 with SHA-256 using the OpenSSL library in C++.\n\n```cpp\n#include <openssl/sha.h>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n\n// Function to compute SHA-256 hash\nstd::string computeSHA256(const std::string& data) {\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    SHA256_CTX sha256;\n    SHA256_Init(&sha256);\n    SHA256_Update(&sha256, data.c_str(), data.size());\n    SHA256_Final(hash, &sha256);\n\n    std::stringstream ss;\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n    return ss.str();\n}\n\nint main() {\n    std::string data = \"example data\";\n    std::string hash = computeSHA256(data);\n    std::cout << \"SHA-256 hash: \" << hash << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, you need the following library:\n\n- OpenSSL\n\nEnsure that OpenSSL is installed on your system and linked during compilation. You can compile the code using:\n\n```bash\ng++ -o hash_example hash_example.cpp -lssl -lcrypto\n```\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "glog-62378b18-7b4d-4d26-87c3-9563f9b4285c",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Vulnerable/Compromised Hash Algorithm\" vulnerability in C++ refers to the use of cryptographic hash functions that are considered weak or broken, such as MD2. MD2 is an older hash function that is no longer considered secure due to its susceptibility to collision attacks, where two different inputs produce the same hash output. This vulnerability can lead to security issues such as data integrity violations and unauthorized data access.\n\n### General Mitigation Advice\n\n1. **Avoid Using Weak Hash Functions**: Replace MD2 with a more secure hash function like SHA-256 or SHA-3.\n2. **Use Well-Maintained Libraries**: Utilize cryptographic libraries that are actively maintained and updated.\n3. **Regularly Update Dependencies**: Ensure that all cryptographic libraries are up-to-date to benefit from the latest security patches.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace MD2 with SHA-256 using the OpenSSL library in C++.\n\n```cpp\n#include <openssl/sha.h>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n\n// Function to compute SHA-256 hash\nstd::string computeSHA256(const std::string& data) {\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    SHA256_CTX sha256;\n    SHA256_Init(&sha256);\n    SHA256_Update(&sha256, data.c_str(), data.size());\n    SHA256_Final(hash, &sha256);\n\n    std::stringstream ss;\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n    return ss.str();\n}\n\nint main() {\n    std::string data = \"example data\";\n    std::string hash = computeSHA256(data);\n    std::cout << \"SHA-256 hash: \" << hash << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, you need the following library:\n\n- OpenSSL\n\nEnsure that OpenSSL is installed on your system and linked during compilation. You can compile the code using:\n\n```bash\ng++ -o hash_example hash_example.cpp -lssl -lcrypto\n```\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "glog-ead70edc-e12d-462d-8c11-8760a5d29d43",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Vulnerable/Compromised Hash Algorithm\" vulnerability in C++ refers to the use of cryptographic hash functions that are considered weak or broken, such as MD2. MD2 is an older hash function that is no longer considered secure due to its susceptibility to collision attacks, where two different inputs produce the same hash output. This vulnerability can lead to security issues such as data integrity violations and unauthorized data access.\n\n### General Mitigation Advice\n\n1. **Avoid Using Weak Hash Functions**: Replace MD2 with a more secure hash function like SHA-256 or SHA-3.\n2. **Use Well-Maintained Libraries**: Utilize cryptographic libraries that are actively maintained and updated.\n3. **Regularly Update Dependencies**: Ensure that all cryptographic libraries are up-to-date to benefit from the latest security patches.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace MD2 with SHA-256 using the OpenSSL library in C++.\n\n```cpp\n#include <openssl/sha.h>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n\n// Function to compute SHA-256 hash\nstd::string computeSHA256(const std::string& data) {\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    SHA256_CTX sha256;\n    SHA256_Init(&sha256);\n    SHA256_Update(&sha256, data.c_str(), data.size());\n    SHA256_Final(hash, &sha256);\n\n    std::stringstream ss;\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n    return ss.str();\n}\n\nint main() {\n    std::string data = \"example data\";\n    std::string hash = computeSHA256(data);\n    std::cout << \"SHA-256 hash: \" << hash << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, you need the following library:\n\n- OpenSSL\n\nEnsure that OpenSSL is installed on your system and linked during compilation. You can compile the code using:\n\n```bash\ng++ -o hash_example hash_example.cpp -lssl -lcrypto\n```\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "glog-fecaaaba-e02e-417b-8551-ea7281a6862c",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Vulnerable/Compromised Hash Algorithm\" vulnerability in C++ refers to the use of cryptographic hash functions that are considered weak or broken, such as MD2. MD2 is an older hash function that is no longer considered secure due to its susceptibility to collision attacks, where two different inputs produce the same hash output. This vulnerability can lead to security issues such as data integrity violations and unauthorized data access.\n\n### General Mitigation Advice\n\n1. **Avoid Using Weak Hash Functions**: Replace MD2 with a more secure hash function like SHA-256 or SHA-3.\n2. **Use Well-Maintained Libraries**: Utilize cryptographic libraries that are actively maintained and updated.\n3. **Regularly Update Dependencies**: Ensure that all cryptographic libraries are up-to-date to benefit from the latest security patches.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace MD2 with SHA-256 using the OpenSSL library in C++.\n\n```cpp\n#include <openssl/sha.h>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n\n// Function to compute SHA-256 hash\nstd::string computeSHA256(const std::string& data) {\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    SHA256_CTX sha256;\n    SHA256_Init(&sha256);\n    SHA256_Update(&sha256, data.c_str(), data.size());\n    SHA256_Final(hash, &sha256);\n\n    std::stringstream ss;\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n    return ss.str();\n}\n\nint main() {\n    std::string data = \"example data\";\n    std::string hash = computeSHA256(data);\n    std::cout << \"SHA-256 hash: \" << hash << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, you need the following library:\n\n- OpenSSL\n\nEnsure that OpenSSL is installed on your system and linked during compilation. You can compile the code using:\n\n```bash\ng++ -o hash_example hash_example.cpp -lssl -lcrypto\n```\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "glog-c3792f33-c821-4d15-916a-302ed603a5a1",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Vulnerable/Compromised Hash Algorithm\" vulnerability in C++ refers to the use of cryptographic hash functions that are considered weak or broken, such as MD2. MD2 is an older hash function that is no longer considered secure due to its susceptibility to collision attacks, where two different inputs produce the same hash output. This vulnerability can lead to security issues such as data integrity violations and unauthorized data access.\n\n### General Mitigation Advice\n\n1. **Avoid Using Weak Hash Functions**: Replace MD2 with a more secure hash function like SHA-256 or SHA-3.\n2. **Use Well-Maintained Libraries**: Utilize cryptographic libraries that are actively maintained and updated.\n3. **Regularly Update Dependencies**: Ensure that all cryptographic libraries are up-to-date to benefit from the latest security patches.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace MD2 with SHA-256 using the OpenSSL library in C++.\n\n```cpp\n#include <openssl/sha.h>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n\n// Function to compute SHA-256 hash\nstd::string computeSHA256(const std::string& data) {\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    SHA256_CTX sha256;\n    SHA256_Init(&sha256);\n    SHA256_Update(&sha256, data.c_str(), data.size());\n    SHA256_Final(hash, &sha256);\n\n    std::stringstream ss;\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n    return ss.str();\n}\n\nint main() {\n    std::string data = \"example data\";\n    std::string hash = computeSHA256(data);\n    std::cout << \"SHA-256 hash: \" << hash << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, you need the following library:\n\n- OpenSSL\n\nEnsure that OpenSSL is installed on your system and linked during compilation. You can compile the code using:\n\n```bash\ng++ -o hash_example hash_example.cpp -lssl -lcrypto\n```\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "glog-51059bc7-a281-4c4a-a4ab-f4623b4e48f4",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Vulnerable/Compromised Hash Algorithm\" vulnerability in C++ refers to the use of cryptographic hash functions that are considered weak or broken, such as MD2. MD2 is an older hash function that is no longer considered secure due to its susceptibility to collision attacks, where two different inputs produce the same hash output. This vulnerability can lead to security issues such as data integrity violations and unauthorized data access.\n\n### General Mitigation Advice\n\n1. **Avoid Using Weak Hash Functions**: Replace MD2 with a more secure hash function like SHA-256 or SHA-3.\n2. **Use Well-Maintained Libraries**: Utilize cryptographic libraries that are actively maintained and updated.\n3. **Regularly Update Dependencies**: Ensure that all cryptographic libraries are up-to-date to benefit from the latest security patches.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace MD2 with SHA-256 using the OpenSSL library in C++.\n\n```cpp\n#include <openssl/sha.h>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n\n// Function to compute SHA-256 hash\nstd::string computeSHA256(const std::string& data) {\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    SHA256_CTX sha256;\n    SHA256_Init(&sha256);\n    SHA256_Update(&sha256, data.c_str(), data.size());\n    SHA256_Final(hash, &sha256);\n\n    std::stringstream ss;\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n    return ss.str();\n}\n\nint main() {\n    std::string data = \"example data\";\n    std::string hash = computeSHA256(data);\n    std::cout << \"SHA-256 hash: \" << hash << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, you need the following library:\n\n- OpenSSL\n\nEnsure that OpenSSL is installed on your system and linked during compilation. You can compile the code using:\n\n```bash\ng++ -o hash_example hash_example.cpp -lssl -lcrypto\n```\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "glog-e2f45978-40b2-4d59-93bd-ccb1a39b2a77",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Vulnerable/Compromised Hash Algorithm\" vulnerability in C++ refers to the use of cryptographic hash functions that are considered weak or broken, such as MD2. MD2 is an older hash function that is no longer considered secure due to its susceptibility to collision attacks, where two different inputs produce the same hash output. This vulnerability can lead to security issues such as data integrity violations and unauthorized data access.\n\n### General Mitigation Advice\n\n1. **Avoid Using Weak Hash Functions**: Replace MD2 with a more secure hash function like SHA-256 or SHA-3.\n2. **Use Well-Maintained Libraries**: Utilize cryptographic libraries that are actively maintained and updated.\n3. **Regularly Update Dependencies**: Ensure that all cryptographic libraries are up-to-date to benefit from the latest security patches.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace MD2 with SHA-256 using the OpenSSL library in C++.\n\n```cpp\n#include <openssl/sha.h>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n\n// Function to compute SHA-256 hash\nstd::string computeSHA256(const std::string& data) {\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    SHA256_CTX sha256;\n    SHA256_Init(&sha256);\n    SHA256_Update(&sha256, data.c_str(), data.size());\n    SHA256_Final(hash, &sha256);\n\n    std::stringstream ss;\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n    return ss.str();\n}\n\nint main() {\n    std::string data = \"example data\";\n    std::string hash = computeSHA256(data);\n    std::cout << \"SHA-256 hash: \" << hash << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, you need the following library:\n\n- OpenSSL\n\nEnsure that OpenSSL is installed on your system and linked during compilation. You can compile the code using:\n\n```bash\ng++ -o hash_example hash_example.cpp -lssl -lcrypto\n```\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "glog-25d8a67b-ba95-4604-bb86-b343dbaa0a1d",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Vulnerable/Compromised Hash Algorithm\" vulnerability in C++ refers to the use of cryptographic hash functions that are considered weak or broken, such as MD2. MD2 is an older hash function that is no longer considered secure due to its susceptibility to collision attacks, where two different inputs produce the same hash output. This vulnerability can lead to security issues such as data integrity violations and unauthorized data access.\n\n### General Mitigation Advice\n\n1. **Avoid Using Weak Hash Functions**: Replace MD2 with a more secure hash function like SHA-256 or SHA-3.\n2. **Use Well-Maintained Libraries**: Utilize cryptographic libraries that are actively maintained and updated.\n3. **Regularly Update Dependencies**: Ensure that all cryptographic libraries are up-to-date to benefit from the latest security patches.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace MD2 with SHA-256 using the OpenSSL library in C++.\n\n```cpp\n#include <openssl/sha.h>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n\n// Function to compute SHA-256 hash\nstd::string computeSHA256(const std::string& data) {\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    SHA256_CTX sha256;\n    SHA256_Init(&sha256);\n    SHA256_Update(&sha256, data.c_str(), data.size());\n    SHA256_Final(hash, &sha256);\n\n    std::stringstream ss;\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n    return ss.str();\n}\n\nint main() {\n    std::string data = \"example data\";\n    std::string hash = computeSHA256(data);\n    std::cout << \"SHA-256 hash: \" << hash << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, you need the following library:\n\n- OpenSSL\n\nEnsure that OpenSSL is installed on your system and linked during compilation. You can compile the code using:\n\n```bash\ng++ -o hash_example hash_example.cpp -lssl -lcrypto\n```\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "glog-64de4cf2-a1a1-4915-a73e-fd9cac1ce796",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Vulnerable/Compromised Hash Algorithm\" vulnerability in C++ refers to the use of cryptographic hash functions that are considered weak or broken, such as MD2. MD2 is an older hash function that is no longer considered secure due to its susceptibility to collision attacks, where two different inputs produce the same hash output. This vulnerability can lead to security issues such as data integrity violations and unauthorized data access.\n\n### General Mitigation Advice\n\n1. **Avoid Using Weak Hash Functions**: Replace MD2 with a more secure hash function like SHA-256 or SHA-3.\n2. **Use Well-Maintained Libraries**: Utilize cryptographic libraries that are actively maintained and updated.\n3. **Regularly Update Dependencies**: Ensure that all cryptographic libraries are up-to-date to benefit from the latest security patches.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace MD2 with SHA-256 using the OpenSSL library in C++.\n\n```cpp\n#include <openssl/sha.h>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n\n// Function to compute SHA-256 hash\nstd::string computeSHA256(const std::string& data) {\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    SHA256_CTX sha256;\n    SHA256_Init(&sha256);\n    SHA256_Update(&sha256, data.c_str(), data.size());\n    SHA256_Final(hash, &sha256);\n\n    std::stringstream ss;\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n    return ss.str();\n}\n\nint main() {\n    std::string data = \"example data\";\n    std::string hash = computeSHA256(data);\n    std::cout << \"SHA-256 hash: \" << hash << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, you need the following library:\n\n- OpenSSL\n\nEnsure that OpenSSL is installed on your system and linked during compilation. You can compile the code using:\n\n```bash\ng++ -o hash_example hash_example.cpp -lssl -lcrypto\n```\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "glog-e0f70413-9e21-480a-b481-1caa04461972",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Vulnerable/Compromised Hash Algorithm\" vulnerability in C++ refers to the use of cryptographic hash functions that are considered weak or broken, such as MD2. MD2 is an older hash function that is no longer considered secure due to its susceptibility to collision attacks, where two different inputs produce the same hash output. This vulnerability can lead to security issues such as data integrity violations and unauthorized data access.\n\n### General Mitigation Advice\n\n1. **Avoid Using Weak Hash Functions**: Replace MD2 with a more secure hash function like SHA-256 or SHA-3.\n2. **Use Well-Maintained Libraries**: Utilize cryptographic libraries that are actively maintained and updated.\n3. **Regularly Update Dependencies**: Ensure that all cryptographic libraries are up-to-date to benefit from the latest security patches.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace MD2 with SHA-256 using the OpenSSL library in C++.\n\n```cpp\n#include <openssl/sha.h>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n\n// Function to compute SHA-256 hash\nstd::string computeSHA256(const std::string& data) {\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    SHA256_CTX sha256;\n    SHA256_Init(&sha256);\n    SHA256_Update(&sha256, data.c_str(), data.size());\n    SHA256_Final(hash, &sha256);\n\n    std::stringstream ss;\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n    return ss.str();\n}\n\nint main() {\n    std::string data = \"example data\";\n    std::string hash = computeSHA256(data);\n    std::cout << \"SHA-256 hash: \" << hash << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, you need the following library:\n\n- OpenSSL\n\nEnsure that OpenSSL is installed on your system and linked during compilation. You can compile the code using:\n\n```bash\ng++ -o hash_example hash_example.cpp -lssl -lcrypto\n```\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "glog-786f8257-87de-4b1e-9d1b-469dd2afe3cb",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Vulnerable/Compromised Hash Algorithm\" vulnerability in C++ refers to the use of cryptographic hash functions that are considered weak or broken, such as MD2. MD2 is an older hash function that is no longer considered secure due to its susceptibility to collision attacks, where two different inputs produce the same hash output. This vulnerability can lead to security issues such as data integrity violations and unauthorized data access.\n\n### General Mitigation Advice\n\n1. **Avoid Using Weak Hash Functions**: Replace MD2 with a more secure hash function like SHA-256 or SHA-3.\n2. **Use Well-Maintained Libraries**: Utilize cryptographic libraries that are actively maintained and updated.\n3. **Regularly Update Dependencies**: Ensure that all cryptographic libraries are up-to-date to benefit from the latest security patches.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace MD2 with SHA-256 using the OpenSSL library in C++.\n\n```cpp\n#include <openssl/sha.h>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n\n// Function to compute SHA-256 hash\nstd::string computeSHA256(const std::string& data) {\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    SHA256_CTX sha256;\n    SHA256_Init(&sha256);\n    SHA256_Update(&sha256, data.c_str(), data.size());\n    SHA256_Final(hash, &sha256);\n\n    std::stringstream ss;\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n    return ss.str();\n}\n\nint main() {\n    std::string data = \"example data\";\n    std::string hash = computeSHA256(data);\n    std::cout << \"SHA-256 hash: \" << hash << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, you need the following library:\n\n- OpenSSL\n\nEnsure that OpenSSL is installed on your system and linked during compilation. You can compile the code using:\n\n```bash\ng++ -o hash_example hash_example.cpp -lssl -lcrypto\n```\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "glog-36bb949b-bd27-49aa-9934-31c0816cd604",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Vulnerable/Compromised Hash Algorithm\" vulnerability in C++ refers to the use of cryptographic hash functions that are considered weak or broken, such as MD2. MD2 is an older hash function that is no longer considered secure due to its susceptibility to collision attacks, where two different inputs produce the same hash output. This vulnerability can lead to security issues such as data integrity violations and unauthorized data access.\n\n### General Mitigation Advice\n\n1. **Avoid Using Weak Hash Functions**: Replace MD2 with a more secure hash function like SHA-256 or SHA-3.\n2. **Use Well-Maintained Libraries**: Utilize cryptographic libraries that are actively maintained and updated.\n3. **Regularly Update Dependencies**: Ensure that all cryptographic libraries are up-to-date to benefit from the latest security patches.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace MD2 with SHA-256 using the OpenSSL library in C++.\n\n```cpp\n#include <openssl/sha.h>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n\n// Function to compute SHA-256 hash\nstd::string computeSHA256(const std::string& data) {\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    SHA256_CTX sha256;\n    SHA256_Init(&sha256);\n    SHA256_Update(&sha256, data.c_str(), data.size());\n    SHA256_Final(hash, &sha256);\n\n    std::stringstream ss;\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n    return ss.str();\n}\n\nint main() {\n    std::string data = \"example data\";\n    std::string hash = computeSHA256(data);\n    std::cout << \"SHA-256 hash: \" << hash << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, you need the following library:\n\n- OpenSSL\n\nEnsure that OpenSSL is installed on your system and linked during compilation. You can compile the code using:\n\n```bash\ng++ -o hash_example hash_example.cpp -lssl -lcrypto\n```\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "glog-32b0e464-1783-4438-91cc-fe770afc6421",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Vulnerable/Compromised Hash Algorithm\" vulnerability in C++ refers to the use of cryptographic hash functions that are considered weak or broken, such as MD2. MD2 is an older hash function that is no longer considered secure due to its susceptibility to collision attacks, where two different inputs produce the same hash output. This vulnerability can lead to security issues such as data integrity violations and unauthorized data access.\n\n### General Mitigation Advice\n\n1. **Avoid Using Weak Hash Functions**: Replace MD2 with a more secure hash function like SHA-256 or SHA-3.\n2. **Use Well-Maintained Libraries**: Utilize cryptographic libraries that are actively maintained and updated.\n3. **Regularly Update Dependencies**: Ensure that all cryptographic libraries are up-to-date to benefit from the latest security patches.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace MD2 with SHA-256 using the OpenSSL library in C++.\n\n```cpp\n#include <openssl/sha.h>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n\n// Function to compute SHA-256 hash\nstd::string computeSHA256(const std::string& data) {\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    SHA256_CTX sha256;\n    SHA256_Init(&sha256);\n    SHA256_Update(&sha256, data.c_str(), data.size());\n    SHA256_Final(hash, &sha256);\n\n    std::stringstream ss;\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n    return ss.str();\n}\n\nint main() {\n    std::string data = \"example data\";\n    std::string hash = computeSHA256(data);\n    std::cout << \"SHA-256 hash: \" << hash << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, you need the following library:\n\n- OpenSSL\n\nEnsure that OpenSSL is installed on your system and linked during compilation. You can compile the code using:\n\n```bash\ng++ -o hash_example hash_example.cpp -lssl -lcrypto\n```\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "glog-30425692-3738-4a7e-916d-9ed892ef08b0",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Vulnerable/Compromised Hash Algorithm\" vulnerability in C++ refers to the use of cryptographic hash functions that are considered weak or broken, such as MD2. MD2 is an older hash function that is no longer considered secure due to its susceptibility to collision attacks, where two different inputs produce the same hash output. This vulnerability can lead to security issues such as data integrity violations and unauthorized data access.\n\n### General Mitigation Advice\n\n1. **Avoid Using Weak Hash Functions**: Replace MD2 with a more secure hash function like SHA-256 or SHA-3.\n2. **Use Well-Maintained Libraries**: Utilize cryptographic libraries that are actively maintained and updated.\n3. **Regularly Update Dependencies**: Ensure that all cryptographic libraries are up-to-date to benefit from the latest security patches.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace MD2 with SHA-256 using the OpenSSL library in C++.\n\n```cpp\n#include <openssl/sha.h>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n\n// Function to compute SHA-256 hash\nstd::string computeSHA256(const std::string& data) {\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    SHA256_CTX sha256;\n    SHA256_Init(&sha256);\n    SHA256_Update(&sha256, data.c_str(), data.size());\n    SHA256_Final(hash, &sha256);\n\n    std::stringstream ss;\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n    return ss.str();\n}\n\nint main() {\n    std::string data = \"example data\";\n    std::string hash = computeSHA256(data);\n    std::cout << \"SHA-256 hash: \" << hash << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, you need the following library:\n\n- OpenSSL\n\nEnsure that OpenSSL is installed on your system and linked during compilation. You can compile the code using:\n\n```bash\ng++ -o hash_example hash_example.cpp -lssl -lcrypto\n```\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "glog-9d9545a1-494c-4cf9-b14c-344a1711fc71",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected C Function Prohibited\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other types of security issues. One such function is `printf`.\n\nThe `printf` function is a common function in C programming for output formatting. However, it can lead to vulnerabilities if not used correctly. For instance, if user-supplied data is passed directly to `printf` as the format string, it can lead to a format string vulnerability, which can allow an attacker to read or write to arbitrary memory, leading to information disclosure or code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` and similar functions with variable format strings. Instead, use safer alternatives that do not allow for format string vulnerabilities, such as `puts` or `fputs` for simple string output. If formatted output is necessary, ensure that the format string is a constant and not user-supplied data.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_supplied_string;\n// ...\nprintf(user_supplied_string);\n```\n\nUse:\n\n```cpp\nchar* user_supplied_string;\n// ...\nputs(user_supplied_string);\n```\n\nOr:\n\n```cpp\nchar* user_supplied_string;\n// ...\nfputs(user_supplied_string, stdout);\n```\n\n## Library Dependencies\n\nThe code examples above require the C standard library, which is typically included with `#include <stdio.h>`.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-76dcabdd-9d64-49c5-a15a-fc52dd219934",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected C Function Prohibited\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other types of security issues. One such function is `printf`.\n\nThe `printf` function is a common function in C programming for output formatting. However, it can lead to vulnerabilities if not used correctly. For instance, if user-supplied data is passed directly to `printf` as the format string, it can lead to a format string vulnerability, which can allow an attacker to read or write to arbitrary memory, leading to information disclosure or code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` and similar functions with variable format strings. Instead, use safer alternatives that do not allow for format string vulnerabilities, such as `puts` or `fputs` for simple string output. If formatted output is necessary, ensure that the format string is a constant and not user-supplied data.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_supplied_string;\n// ...\nprintf(user_supplied_string);\n```\n\nUse:\n\n```cpp\nchar* user_supplied_string;\n// ...\nputs(user_supplied_string);\n```\n\nOr:\n\n```cpp\nchar* user_supplied_string;\n// ...\nfputs(user_supplied_string, stdout);\n```\n\n## Library Dependencies\n\nThe code examples above require the C standard library, which is typically included with `#include <stdio.h>`.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-fc60d20a-6b65-4945-b87e-8f5c7c00efbf",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected C Function Prohibited\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other types of security issues. One such function is `printf`.\n\nThe `printf` function is a common function in C programming for output formatting. However, it can lead to vulnerabilities if not used correctly. For instance, if user-supplied data is passed directly to `printf` as the format string, it can lead to a format string vulnerability, which can allow an attacker to read or write to arbitrary memory, leading to information disclosure or code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` and similar functions with variable format strings. Instead, use safer alternatives that do not allow for format string vulnerabilities, such as `puts` or `fputs` for simple string output. If formatted output is necessary, ensure that the format string is a constant and not user-supplied data.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_supplied_string;\n// ...\nprintf(user_supplied_string);\n```\n\nUse:\n\n```cpp\nchar* user_supplied_string;\n// ...\nputs(user_supplied_string);\n```\n\nOr:\n\n```cpp\nchar* user_supplied_string;\n// ...\nfputs(user_supplied_string, stdout);\n```\n\n## Library Dependencies\n\nThe code examples above require the C standard library, which is typically included with `#include <stdio.h>`.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-7633b450-1674-49f1-9221-f3b2f09aa390",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected C Function Prohibited\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other types of security issues. One such function is `printf`.\n\nThe `printf` function is a common function in C programming for output formatting. However, it can lead to vulnerabilities if not used correctly. For instance, if user-supplied data is passed directly to `printf` as the format string, it can lead to a format string vulnerability, which can allow an attacker to read or write to arbitrary memory, leading to information disclosure or code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` and similar functions with variable format strings. Instead, use safer alternatives that do not allow for format string vulnerabilities, such as `puts` or `fputs` for simple string output. If formatted output is necessary, ensure that the format string is a constant and not user-supplied data.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_supplied_string;\n// ...\nprintf(user_supplied_string);\n```\n\nUse:\n\n```cpp\nchar* user_supplied_string;\n// ...\nputs(user_supplied_string);\n```\n\nOr:\n\n```cpp\nchar* user_supplied_string;\n// ...\nfputs(user_supplied_string, stdout);\n```\n\n## Library Dependencies\n\nThe code examples above require the C standard library, which is typically included with `#include <stdio.h>`.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-291a16bc-2341-40f5-aa56-d8d4583741aa",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected C Function Prohibited\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other types of security issues. One such function is `printf`.\n\nThe `printf` function is a common function in C programming for output formatting. However, it can lead to vulnerabilities if not used correctly. For instance, if user-supplied data is passed directly to `printf` as the format string, it can lead to a format string vulnerability, which can allow an attacker to read or write to arbitrary memory, leading to information disclosure or code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` and similar functions with variable format strings. Instead, use safer alternatives that do not allow for format string vulnerabilities, such as `puts` or `fputs` for simple string output. If formatted output is necessary, ensure that the format string is a constant and not user-supplied data.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_supplied_string;\n// ...\nprintf(user_supplied_string);\n```\n\nUse:\n\n```cpp\nchar* user_supplied_string;\n// ...\nputs(user_supplied_string);\n```\n\nOr:\n\n```cpp\nchar* user_supplied_string;\n// ...\nfputs(user_supplied_string, stdout);\n```\n\n## Library Dependencies\n\nThe code examples above require the C standard library, which is typically included with `#include <stdio.h>`.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-b36c68f0-71d1-45ad-9eab-f0adfda4c252",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected C Function Prohibited\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other types of security issues. One such function is `printf`.\n\nThe `printf` function is a common function in C programming for output formatting. However, it can lead to vulnerabilities if not used correctly. For instance, if user-supplied data is passed directly to `printf` as the format string, it can lead to a format string vulnerability, which can allow an attacker to read or write to arbitrary memory, leading to information disclosure or code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` and similar functions with variable format strings. Instead, use safer alternatives that do not allow for format string vulnerabilities, such as `puts` or `fputs` for simple string output. If formatted output is necessary, ensure that the format string is a constant and not user-supplied data.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_supplied_string;\n// ...\nprintf(user_supplied_string);\n```\n\nUse:\n\n```cpp\nchar* user_supplied_string;\n// ...\nputs(user_supplied_string);\n```\n\nOr:\n\n```cpp\nchar* user_supplied_string;\n// ...\nfputs(user_supplied_string, stdout);\n```\n\n## Library Dependencies\n\nThe code examples above require the C standard library, which is typically included with `#include <stdio.h>`.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-9655f16d-ba55-49be-a959-1dda7c9a13b9",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-61282d35-9a4c-4ba4-908f-a1ebae76ed6d",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-8e4ea937-4173-484c-bce2-17c04d58646b",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-d780ab2f-38e0-473c-a9b2-c8391c37a43c",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-e0f2e97d-268f-4fa4-a366-d8f9f71904d9",
              "name": "AWeakCipherModeOfOperationWasUsed",
              "shortDescription": {
                "text": "A potentially weak cipher mode of operation was used."
              },
              "fullDescription": {
                "text": "A weak cipher mode of operation was used: A potentially weak cipher mode of operation was used."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md",
              "help": {
                "text": "Consider using CBC, CTR, or GCM.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS182720.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "Medium",
                "precision": "medium",
                "problem.severity": "warning",
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-131b32cb-76bf-4ef1-8473-ceeada41bca5",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Vulnerable/Compromised Hash Algorithm\" vulnerability in C++ refers to the use of cryptographic hash functions that are considered weak or broken, such as MD2. MD2 is an older hash function that is no longer considered secure due to its susceptibility to collision attacks, where two different inputs produce the same hash output. This vulnerability can lead to security issues such as data integrity violations and unauthorized data access.\n\n### General Mitigation Advice\n\n1. **Avoid Using Weak Hash Functions**: Replace MD2 with a more secure hash function like SHA-256 or SHA-3.\n2. **Use Well-Maintained Libraries**: Utilize cryptographic libraries that are actively maintained and updated.\n3. **Regularly Update Dependencies**: Ensure that all cryptographic libraries are up-to-date to benefit from the latest security patches.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace MD2 with SHA-256 using the OpenSSL library in C++.\n\n```cpp\n#include <openssl/sha.h>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n\n// Function to compute SHA-256 hash\nstd::string computeSHA256(const std::string& data) {\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    SHA256_CTX sha256;\n    SHA256_Init(&sha256);\n    SHA256_Update(&sha256, data.c_str(), data.size());\n    SHA256_Final(hash, &sha256);\n\n    std::stringstream ss;\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n    return ss.str();\n}\n\nint main() {\n    std::string data = \"example data\";\n    std::string hash = computeSHA256(data);\n    std::cout << \"SHA-256 hash: \" << hash << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, you need the following library:\n\n- OpenSSL\n\nEnsure that OpenSSL is installed on your system and linked during compilation. You can compile the code using:\n\n```bash\ng++ -o hash_example hash_example.cpp -lssl -lcrypto\n```\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "glog-e4d7fc90-a038-4220-91a6-a58271353521",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected C Function Prohibited\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other types of security issues. One such function is `printf`.\n\nThe `printf` function is a common function in C programming for output formatting. However, it can lead to vulnerabilities if not used correctly. For instance, if user-supplied data is passed directly to `printf` as the format string, it can lead to a format string vulnerability, which can allow an attacker to read or write to arbitrary memory, leading to information disclosure or code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` and similar functions with variable format strings. Instead, use safer alternatives that do not allow for format string vulnerabilities, such as `puts` or `fputs` for simple string output. If formatted output is necessary, ensure that the format string is a constant and not user-supplied data.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_supplied_string;\n// ...\nprintf(user_supplied_string);\n```\n\nUse:\n\n```cpp\nchar* user_supplied_string;\n// ...\nputs(user_supplied_string);\n```\n\nOr:\n\n```cpp\nchar* user_supplied_string;\n// ...\nfputs(user_supplied_string, stdout);\n```\n\n## Library Dependencies\n\nThe code examples above require the C standard library, which is typically included with `#include <stdio.h>`.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-71c77052-aeea-4646-ba96-f5eb518a835a",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected C Function Prohibited\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other types of security issues. One such function is `printf`.\n\nThe `printf` function is a common function in C programming for output formatting. However, it can lead to vulnerabilities if not used correctly. For instance, if user-supplied data is passed directly to `printf` as the format string, it can lead to a format string vulnerability, which can allow an attacker to read or write to arbitrary memory, leading to information disclosure or code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` and similar functions with variable format strings. Instead, use safer alternatives that do not allow for format string vulnerabilities, such as `puts` or `fputs` for simple string output. If formatted output is necessary, ensure that the format string is a constant and not user-supplied data.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_supplied_string;\n// ...\nprintf(user_supplied_string);\n```\n\nUse:\n\n```cpp\nchar* user_supplied_string;\n// ...\nputs(user_supplied_string);\n```\n\nOr:\n\n```cpp\nchar* user_supplied_string;\n// ...\nfputs(user_supplied_string, stdout);\n```\n\n## Library Dependencies\n\nThe code examples above require the C standard library, which is typically included with `#include <stdio.h>`.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-6132b22f-a970-44f4-acbf-d9f4875c7725",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the C function `memcpy` arises when there is a potential for buffer overflow, which occurs when the destination buffer is not large enough to hold the data being copied. This can lead to undefined behavior, including data corruption, crashes, and security vulnerabilities such as arbitrary code execution. In the provided code snippet, the use of `memcpy(hndl, bias_hndl, result_size * sizeof(float))` suggests that the size of the destination buffer `hndl` may not be properly validated against the size of the data being copied from `bias_hndl`.\n\n### General Mitigation Advice\n\n1. **Validate Buffer Sizes**: Ensure that the destination buffer is large enough to accommodate the data being copied. This involves checking the size of the destination buffer against the size of the source data.\n2. **Use Safer Alternatives**: Consider using safer alternatives like `memmove` or `std::copy` in C++ which provide additional safety checks.\n3. **Boundary Checks**: Implement boundary checks to prevent buffer overflows by ensuring that the indices used in memory operations are within valid ranges.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in the code.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstring> // Required for memcpy\n#include <algorithm> // Required for std::min\n\nvoid safe_memcpy(float* hndl, const float* bias_hndl, size_t result_size, size_t hndl_size) {\n    // Ensure that the destination buffer is large enough\n    size_t copy_size = std::min(result_size, hndl_size) * sizeof(float);\n    memcpy(hndl, bias_hndl, copy_size);\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library dependencies are required:\n\n- `<cstring>`: Provides the `memcpy` function.\n- `<algorithm>`: Provides the `std::min` function for safe size calculation.\n\n### Relevant Resources\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-99efb0ff-148e-4892-b496-389a0792bc51",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" is a vulnerability that arises when a C++ program uses certain C standard library functions that are known to be insecure. These functions are often prohibited because they can lead to buffer overflows, format string vulnerabilities, or other types of security issues. \n\nOne such function is `ctime`. The `ctime` function converts a time_t value into a string, but it does not perform any bounds checking, which can lead to buffer overflow vulnerabilities.\n\n## Mitigation Advice\n\nAvoid using the `ctime` function. Instead, use safer alternatives that perform bounds checking, such as `ctime_s` or `strftime`. \n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\n#include <time.h>\n\nvoid print_time(time_t time) {\n    char* time_str = ctime(&time);\n    printf(\"%s\", time_str);\n}\n```\n\nUse:\n\n```cpp\n#include <time.h>\n\nvoid print_time(time_t time) {\n    char time_str[26];\n    ctime_s(time_str, sizeof time_str, &time);\n    printf(\"%s\", time_str);\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- time.h\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-1ae11b5f-e2be-487c-80a5-0197da2c16f3",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability identified in the C function `malloc` arises from the potential for integer overflow when calculating the size of memory to allocate. Specifically, the expression `zenLibBufPoolLimit * sizeof(zenLibBufPool)` can result in an overflow if `zenLibBufPoolLimit` is large enough, leading to a smaller than intended memory allocation. This can cause buffer overflows when the allocated memory is used, potentially leading to undefined behavior, crashes, or security vulnerabilities such as arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that inputs used in size calculations are within expected bounds to prevent overflow.\n2. **Safe Arithmetic**: Use safe arithmetic functions or libraries that check for overflow conditions.\n3. **Memory Allocation Checks**: Always check the result of memory allocation functions to ensure they are not `NULL` before using the allocated memory.\n4. **Use of Safer Functions**: Consider using safer alternatives or wrappers that handle size calculations and overflow checks.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risk of integer overflow in the `malloc` call, you can perform a check before the allocation:\n\n```cpp\n#include <limits>\n#include <cstdlib>\n#include <iostream>\n\n// Assuming zenLibBufPool is a type and zenLibBufPoolLimit is a variable\ntypedef int zenLibBufPool; // Example type, replace with actual type\nsize_t zenLibBufPoolLimit = 1000; // Example limit, replace with actual limit\n\nint main() {\n    // Check for potential overflow\n    if (zenLibBufPoolLimit > std::numeric_limits<size_t>::max() / sizeof(zenLibBufPool)) {\n        std::cerr << \"Potential overflow detected, aborting allocation.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    // Safe allocation\n    zenLibBufPool* buffer = static_cast<zenLibBufPool*>(malloc(zenLibBufPoolLimit * sizeof(zenLibBufPool)));\n    if (buffer == nullptr) {\n        std::cerr << \"Memory allocation failed.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    // Use the buffer...\n\n    // Free the allocated memory\n    free(buffer);\n\n    return EXIT_SUCCESS;\n}\n```\n\n### Library Dependencies\n\nThe code example requires the following standard libraries:\n\n- `<limits>`: For `std::numeric_limits`.\n- `<cstdlib>`: For `malloc`, `free`, and `EXIT_FAILURE`.\n- `<iostream>`: For input and output operations.\n\n### Relevant Links\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration - CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-44e0cf9d-5c4e-479b-bbc9-ae411866f2a2",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. These functions are often prohibited in secure coding standards and should be avoided.\n\nIn this case, the `fopen` function is used, which can lead to vulnerabilities if not used correctly. The `fopen` function opens a file and returns a pointer to the file. If the file does not exist or cannot be found, the function returns a null pointer. This can lead to null pointer dereferencing if not handled correctly.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to `fopen` such as `fopen_s` (in C11) or file stream objects in C++. These alternatives provide better error handling and are less prone to vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the `fopen` function with `fopen_s` or file stream objects. Here is an example of how to use `fopen_s`:\n\n```cpp\nFILE* fp = NULL;\nerrno_t err = fopen_s(&fp, \"file.txt\", \"r\");\nif (err != 0) {\n    // Handle error\n} else {\n    // Use file\n    fclose(fp);\n}\n```\n\nAnd here is an example of how to use file stream objects:\n\n```cpp\n#include <fstream>\n\nstd::ifstream file(\"file.txt\");\nif (!file) {\n    // Handle error\n} else {\n    // Use file\n    file.close();\n}\n```\n\n## Library Dependencies\n\nThe code examples above require the following library dependencies:\n\n- `<stdio.h>` or `<cstdio>` for `fopen_s`\n- `<fstream>` for file stream objects\n\n## References\n"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-76b6332e-125a-4b36-b5d8-7708b5e4f793",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other issues. These functions are often prohibited in secure coding standards.\n\nThe `getenv` function is one such function. It is used to retrieve the value of an environment variable from the process environment. The problem with `getenv` is that it returns a pointer to a string that may be overwritten by subsequent calls to `getenv`, `setenv`, or `unsetenv`. This can lead to race conditions if the application is multithreaded.\n\n## Mitigation Advice\n\nAvoid using `getenv` in multithreaded applications. If you need to use environment variables, consider copying the values into your own buffers to avoid race conditions.\n\n## Source Code Fix Recommendation\n\nInstead of using `getenv`, you can use `secure_getenv` if it's available on your platform. `secure_getenv` behaves the same as `getenv` but returns NULL if the process is being run with elevated privileges. This can help prevent privilege escalation attacks.\n\nHere's an example of how you can use `secure_getenv`:\n\n```cpp\n#include <stdlib.h>\n\nconst char* value = secure_getenv(\"MY_VARIABLE\");\nif (value != NULL) {\n    // Use the value\n} else {\n    // Handle the error\n}\n```\n\n## Library Dependencies\n\nThe `getenv` and `secure_getenv` functions are part of the C standard library, so you don't need any additional libraries to use them.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-ff584fc7-6755-4a7e-adab-32392a242bbc",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected C Function Prohibited\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflow, format string vulnerabilities, or other types of security issues. One such function is `printf`.\n\nThe `printf` function is a common function in C programming for output formatting. However, it can lead to vulnerabilities if not used correctly. For instance, if user-supplied data is passed directly to `printf` as the format string, it can lead to a format string vulnerability, which can allow an attacker to read or write to arbitrary memory, leading to information disclosure or code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` and similar functions with variable format strings. Instead, use safer alternatives that do not allow for format string vulnerabilities, such as `puts` or `fputs` for simple string output. If formatted output is necessary, ensure that the format string is a constant and not user-supplied data.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_supplied_string;\n// ...\nprintf(user_supplied_string);\n```\n\nUse:\n\n```cpp\nchar* user_supplied_string;\n// ...\nputs(user_supplied_string);\n```\n\nOr:\n\n```cpp\nchar* user_supplied_string;\n// ...\nfputs(user_supplied_string, stdout);\n```\n\n## Library Dependencies\n\nThe code examples above require the C standard library, which is typically included with `#include <stdio.h>`.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-94a548eb-8a35-4d5e-893c-55eff9cce038",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, leading to potential memory allocation issues such as buffer overflows, memory leaks, or undefined behavior. This vulnerability typically occurs when the size parameter passed to `malloc` is incorrect, unchecked, or derived from untrusted sources, which can result in insufficient memory allocation or excessive memory consumption.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate input sizes before using them in memory allocation functions.\n2. **Use Safer Alternatives**: Consider using C++ memory management features like `new` and `delete` or smart pointers (`std::unique_ptr`, `std::shared_ptr`) which provide automatic memory management.\n3. **Check Return Values**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n4. **Limit Memory Usage**: Implement limits on the amount of memory that can be allocated to prevent excessive memory consumption.\n5. **Free Allocated Memory**: Ensure that all allocated memory is properly freed to prevent memory leaks.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstdlib> // Required for malloc and free\n\nint main() {\n    size_t size = 10; // Example size, should be validated\n    if (size <= 0 || size > MAX_ALLOWED_SIZE) { // Validate size\n        std::cerr << \"Invalid size for memory allocation.\" << std::endl;\n        return 1;\n    }\n\n    int* ptr = (int*)malloc(size * sizeof(int));\n    if (ptr == nullptr) { // Check if malloc succeeded\n        std::cerr << \"Memory allocation failed.\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n    for (size_t i = 0; i < size; ++i) {\n        ptr[i] = i;\n    }\n\n    // Free the allocated memory\n    free(ptr);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<cstdlib>`: For `malloc` and `free` functions.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)\n\nThese links are verified to be active and accessible to anonymous users."
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-28bd4bc9-d445-4f85-bd8b-7962f5d49be3",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ programming arises when the `malloc` function is used incorrectly, potentially leading to memory allocation issues such as buffer overflows, memory leaks, or undefined behavior. In the specific case of `malloc(sizeof(float))`, the vulnerability may occur if the allocated memory is insufficient for the intended use, or if the allocation is not properly checked for success, leading to potential dereferencing of a null pointer.\n\n### General Mitigation Advice\n\n1. **Check for Allocation Success**: Always verify that the memory allocation was successful by checking if the returned pointer is not `NULL`.\n2. **Use `new` in C++**: Prefer using `new` and `delete` in C++ for memory management, as they provide better type safety and integration with C++ object semantics.\n3. **Proper Size Calculation**: Ensure that the size passed to `malloc` is correct and accounts for the number of elements and their type.\n4. **Free Allocated Memory**: Always free the allocated memory when it is no longer needed to prevent memory leaks.\n\n### Source Code Fix Recommendation\n\nHere is a corrected version of the code using `new` instead of `malloc`:\n\n```cpp\n#include <iostream>\n\nint main() {\n    // Allocate memory for a single float\n    float* ptr = new (std::nothrow) float;\n    \n    // Check if allocation was successful\n    if (ptr == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n    *ptr = 3.14f;\n    std::cout << \"Value: \" << *ptr << std::endl;\n\n    // Free the allocated memory\n    delete ptr;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nThe above code example requires the following standard library:\n\n- `<iostream>`: For input and output operations.\n\n### Relevant Links\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-3a4db3dc-6b86-43bf-baaf-8fc4dc97e787",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ typically arises from improper use of the `malloc` function, which is used to allocate memory dynamically. The specific issue here is with the expression `malloc(sizeof(*c_buffers))`. This expression may lead to incorrect memory allocation if `c_buffers` is not properly defined or if its size is not what is intended. This can result in buffer overflows, memory corruption, or undefined behavior, which are common vulnerabilities in C/C++ programming.\n\n### General Mitigation Advice\n\n1. **Validate Input:** Ensure that all inputs that affect memory allocation are validated to prevent excessive or insufficient allocation.\n2. **Check Return Values:** Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Use Safer Alternatives:** Consider using safer alternatives like `new` in C++ or higher-level data structures that manage memory automatically.\n4. **Initialize Memory:** Use functions like `calloc` that initialize memory to zero, reducing the risk of using uninitialized memory.\n5. **Free Allocated Memory:** Ensure that all dynamically allocated memory is properly freed to prevent memory leaks.\n\n### Source Code Fix Recommendation\n\nTo fix the specific vulnerability sink, ensure that the size passed to `malloc` is correct and corresponds to the intended data structure. Here is a corrected version of the code:\n\n```cpp\n#include <cstdlib> // Required for malloc and free\n#include <iostream> // Required for std::cout\n\nstruct Buffer {\n    // Define the structure of Buffer\n    int data;\n    // Add other members as needed\n};\n\nint main() {\n    // Correctly allocate memory for a Buffer object\n    Buffer* c_buffers = (Buffer*)malloc(sizeof(Buffer));\n    if (c_buffers == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n    c_buffers->data = 42;\n    std::cout << \"Buffer data: \" << c_buffers->data << std::endl;\n\n    // Free the allocated memory\n    free(c_buffers);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard libraries are required:\n\n- `<cstdlib>`: For `malloc` and `free` functions.\n- `<iostream>`: For input and output operations.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-4d213a9d-d0ea-49e0-8928-6963371b5cc4",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (memcpy)\" vulnerability in C++ arises when the `memcpy` function is used incorrectly, potentially leading to buffer overflows, data corruption, or undefined behavior. In the provided code snippet, `memcpy(&t, &u, sizeof(U))`, the vulnerability may occur if the size of the destination buffer `t` is smaller than the size of the source buffer `u`. This can lead to overwriting adjacent memory, causing security vulnerabilities such as data leaks or application crashes.\n\n### General Mitigation Advice\n\n1. **Ensure Buffer Sizes**: Always ensure that the destination buffer is large enough to hold the data being copied.\n2. **Use Safer Alternatives**: Consider using safer alternatives like `std::copy` or `std::memmove` if overlapping memory regions are involved.\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other memory issues.\n4. **Code Reviews**: Regularly conduct code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo fix the specific vulnerability in the code snippet, ensure that the destination buffer `t` is of the correct size and use safer functions if possible. Here's an example fix:\n\n```cpp\n#include <cstring> // Required for memcpy\n\nstruct U {\n    // Assume U has some members\n};\n\nstruct T {\n    // Ensure T is at least as large as U\n    // Add members to match or exceed the size of U\n};\n\nint main() {\n    U u;\n    T t;\n\n    // Ensure T is large enough to hold U\n    static_assert(sizeof(T) >= sizeof(U), \"T must be at least as large as U\");\n\n    // Use memcpy safely\n    std::memcpy(&t, &u, sizeof(U));\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for using `memcpy`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-53356af0-3b96-40ad-946f-ebdca1e93b58",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ typically arises from improper use of the `malloc` function, which is used to allocate memory dynamically. The specific issue here is with the expression `malloc(sizeof(*c_buffers))`. This expression may lead to incorrect memory allocation if `c_buffers` is not properly defined or if its size is not what is intended. This can result in buffer overflows, memory corruption, or undefined behavior, which are common vulnerabilities in C/C++ programming.\n\n### General Mitigation Advice\n\n1. **Validate Input:** Ensure that all inputs that affect memory allocation are validated to prevent excessive or insufficient allocation.\n2. **Check Return Values:** Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Use Safer Alternatives:** Consider using safer alternatives like `new` in C++ or higher-level data structures that manage memory automatically.\n4. **Initialize Memory:** Use functions like `calloc` that initialize memory to zero, reducing the risk of using uninitialized memory.\n5. **Free Allocated Memory:** Ensure that all dynamically allocated memory is properly freed to prevent memory leaks.\n\n### Source Code Fix Recommendation\n\nTo fix the specific vulnerability sink, ensure that the size passed to `malloc` is correct and corresponds to the intended data structure. Here is a corrected version of the code:\n\n```cpp\n#include <cstdlib> // Required for malloc and free\n#include <iostream> // Required for std::cout\n\nstruct Buffer {\n    // Define the structure of Buffer\n    int data;\n    // Add other members as needed\n};\n\nint main() {\n    // Correctly allocate memory for a Buffer object\n    Buffer* c_buffers = (Buffer*)malloc(sizeof(Buffer));\n    if (c_buffers == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n    c_buffers->data = 42;\n    std::cout << \"Buffer data: \" << c_buffers->data << std::endl;\n\n    // Free the allocated memory\n    free(c_buffers);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard libraries are required:\n\n- `<cstdlib>`: For `malloc` and `free` functions.\n- `<iostream>`: For input and output operations.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-b4ef34bb-2ff4-4127-a0a7-e17843081c42",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question involves the use of the `memcpy` function in C++. The `memcpy` function is used to copy a block of memory from one location to another. The specific issue arises when the size of the memory to be copied is not correctly specified, potentially leading to buffer overflows. In the provided code snippet, the size argument of `memcpy` is incorrectly set to `sizeof(float)`, which may not match the actual size of the data being copied. This can result in undefined behavior, including memory corruption, crashes, or security vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Validate Input Sizes**: Ensure that the size of the data being copied is correctly calculated and does not exceed the size of the destination buffer.\n2. **Use Safer Functions**: Consider using safer alternatives like `std::copy` or `memmove` if overlapping memory regions are involved.\n3. **Boundary Checks**: Implement boundary checks to ensure that the source and destination buffers are large enough to accommodate the data being copied.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other memory-related issues.\n\n### Source Code Fix Recommendation\n\nTo fix the vulnerability, ensure that the size of the data being copied is correctly calculated. For example, if `col_data` is intended to hold a certain number of `float` elements, the size should be adjusted accordingly:\n\n```cpp\n// Assuming 'num_elements' is the number of float elements to be copied\nmemcpy(col_data, input_data + (ih * width + iw) * depth,\n       num_elements * sizeof(float));\n```\n\n### Library Dependencies\n\nThe code example provided does not require any additional library dependencies beyond the standard C++ libraries. However, ensure that the following headers are included:\n\n```cpp\n#include <cstring> // For memcpy\n```\n\n### Relevant OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-f4bc3d51-7633-4b31-a319-71d359223f12",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (memcpy)\" vulnerability in C++ arises when the `memcpy` function is used incorrectly, leading to potential data corruption, undefined behavior, or security vulnerabilities. In the provided code snippet, the issue is with the use of `memcpy` to copy data from an `int32_t` type to a `float` type, which can result in incorrect data interpretation and potential security risks.\n\n### General Mitigation Advice\n\n1. **Type Safety**: Ensure that the source and destination types are compatible. Avoid using `memcpy` for type conversions between fundamentally different types.\n2. **Bounds Checking**: Always verify that the size of the data being copied does not exceed the size of the destination buffer.\n3. **Use Safer Alternatives**: Consider using type-safe alternatives or functions that perform necessary checks, such as `std::copy` for C++.\n\n### Source Code Fix Recommendation\n\nTo fix the specific vulnerability, ensure that the data types are compatible or use a type-safe method to perform the conversion:\n\n```cpp\n#include <cstdint>\n#include <cstring>\n#include <iostream>\n\nint main() {\n    int32_t inter_temp = 42;\n    float float_value;\n\n    // Correctly convert int32_t to float using static_cast\n    float_value = static_cast<float>(inter_temp);\n\n    std::cout << \"Converted value: \" << float_value << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nThe code example requires the following standard C++ libraries:\n\n- `<cstdint>`: For fixed-width integer types.\n- `<cstring>`: For C-style string and memory manipulation functions (though not used in the fixed code).\n- `<iostream>`: For input and output stream operations.\n\n### Relevant Resources\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration (CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer)](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-ea2f3f58-ab1d-4867-be0e-dabc189f916d",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ typically arises from improper use of the `malloc` function, which is used to allocate memory dynamically. The specific issue in the provided code snippet is the use of `malloc(sizeof(aocl_post_op_bias))`. This can lead to vulnerabilities such as buffer overflows or memory corruption if the size of the allocated memory does not match the actual size needed for the data structure or if the memory is not properly managed (e.g., not freed after use).\n\n### General Mitigation Advice\n\n1. **Use `new` in C++**: Prefer using `new` and `delete` in C++ for dynamic memory allocation and deallocation, as they are type-safe and automatically call constructors and destructors.\n2. **Check for Allocation Failure**: Always check if the memory allocation was successful by verifying that the returned pointer is not `NULL`.\n3. **Free Allocated Memory**: Ensure that all dynamically allocated memory is freed when it is no longer needed to prevent memory leaks.\n4. **Use Smart Pointers**: Consider using smart pointers like `std::unique_ptr` or `std::shared_ptr` to manage dynamic memory automatically.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <memory> // For std::unique_ptr\n\n// Assuming aocl_post_op_bias is a struct or class\nstruct aocl_post_op_bias {\n    // Members of the struct\n};\n\nint main() {\n    // Use smart pointer for automatic memory management\n    std::unique_ptr<aocl_post_op_bias> biasPtr = std::make_unique<aocl_post_op_bias>();\n\n    // Use the object as needed\n    // ...\n\n    // No need to manually free memory, smart pointer will handle it\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<memory>`: Required for using smart pointers like `std::unique_ptr`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-9c8d4c5d-ae78-4d4e-bdb1-3a446b444943",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question arises from the misuse of the `memcpy` function in C++. The function call:\n\n```cpp\nmemcpy((bf16_val), (char *)(float_value) + 2, sizeof(int16_t));\n```\n\nThis line of code attempts to copy a portion of a `float` value into a `bf16_val` buffer. The issue here is that the `memcpy` function is used to copy memory without any bounds checking, which can lead to buffer overflows if the destination buffer is not large enough to hold the data being copied. This can result in undefined behavior, including data corruption, crashes, or security vulnerabilities such as arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the data being copied.\n2. **Use Safer Functions**: Consider using safer alternatives like `std::copy` or `std::memmove` if applicable, which provide better type safety and can prevent some common errors.\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n4. **Code Reviews**: Regularly perform code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo mitigate the vulnerability, ensure that the destination buffer is properly sized and consider using a safer alternative to `memcpy`. Here's a revised version of the code:\n\n```cpp\n#include <cstring>  // For std::memcpy\n#include <cstdint>  // For std::int16_t\n\nvoid safeCopy(float* float_value, std::int16_t* bf16_val) {\n    if (bf16_val != nullptr && float_value != nullptr) {\n        // Ensure the destination buffer is large enough\n        std::memcpy(bf16_val, reinterpret_cast<char*>(float_value) + 2, sizeof(std::int16_t));\n    }\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard libraries are required:\n\n- `<cstring>`: For the `std::memcpy` function.\n- `<cstdint>`: For fixed-width integer types like `std::int16_t`.\n\n### Relevant OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-d6960acb-316b-410f-a7d3-e929a975ef59",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ typically arises from improper use of the `malloc` function, which is used to allocate memory dynamically. The specific issue with `malloc(sizeof(aocl_post_op_eltwise))` is that it may not correctly allocate the intended amount of memory if `aocl_post_op_eltwise` is a pointer or an incomplete type. This can lead to buffer overflows, memory corruption, or undefined behavior.\n\n### General Mitigation Advice\n\n1. **Use `sizeof` Correctly**: Ensure that `sizeof` is used on the correct type. If `aocl_post_op_eltwise` is a pointer, use the dereferenced type.\n2. **Check for NULL**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Use `new` in C++**: Prefer using `new` and `delete` in C++ for memory management, as they are type-safe and call constructors/destructors.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib> // for malloc and free\n#include <iostream>\n\n// Assuming aocl_post_op_eltwise is a struct or class\nstruct aocl_post_op_eltwise {\n    // member variables\n};\n\nint main() {\n    // Correct usage of sizeof with the actual type\n    aocl_post_op_eltwise* ptr = (aocl_post_op_eltwise*)malloc(sizeof(aocl_post_op_eltwise));\n    \n    if (ptr == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n\n    // Free the allocated memory\n    free(ptr);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<iostream>`: Required for input/output operations.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-127a595e-2e67-4b3a-957d-10a008b8878a",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ typically arises from improper use of the `malloc` function, which is used to allocate memory dynamically. This can lead to several issues, such as buffer overflows, memory leaks, or undefined behavior if the allocated memory is not managed correctly. In the provided code snippet, the vulnerability may occur if `max_post_ops_seq_length` is not properly validated, leading to an incorrect or excessive amount of memory being allocated.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that `max_post_ops_seq_length` is validated to be within a reasonable range before using it in `malloc`.\n2. **Check for NULL**: Always check if `malloc` returns `NULL`, which indicates that the memory allocation failed.\n3. **Free Allocated Memory**: Ensure that any memory allocated with `malloc` is properly freed using `free` to prevent memory leaks.\n4. **Use Safer Alternatives**: Consider using safer alternatives like `calloc`, which initializes the allocated memory to zero, or C++ constructs like `std::vector` that manage memory automatically.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstdlib> // for malloc and free\n\n#define MAX_POST_OPS_SEQ_LENGTH 1000 // Define a reasonable maximum\n\ntypedef int AOCL_POST_OP_TYPE; // Example type definition\n\nint main() {\n    size_t max_post_ops_seq_length = 10; // Example value, should be validated\n\n    // Validate max_post_ops_seq_length\n    if (max_post_ops_seq_length > MAX_POST_OPS_SEQ_LENGTH) {\n        std::cerr << \"Error: max_post_ops_seq_length is too large.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    // Allocate memory\n    AOCL_POST_OP_TYPE* post_ops = (AOCL_POST_OP_TYPE*)malloc(max_post_ops_seq_length * sizeof(AOCL_POST_OP_TYPE));\n    \n    // Check if malloc succeeded\n    if (post_ops == NULL) {\n        std::cerr << \"Error: Memory allocation failed.\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    // Use the allocated memory\n    // ...\n\n    // Free the allocated memory\n    free(post_ops);\n\n    return EXIT_SUCCESS;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<cstdlib>`: For `malloc` and `free` functions.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-36458468-0840-4a65-a943-a4e68d82c670",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ typically arises from improper memory allocation using the `malloc` function. This can lead to various issues such as buffer overflows, memory leaks, or undefined behavior if the allocated memory is not properly managed. In the specific case of `malloc(sizeof(aocl_post_op_matrix_mul))`, the vulnerability may occur if the size of `aocl_post_op_matrix_mul` is not correctly calculated or if the memory allocation is not checked for success before use.\n\n### General Mitigation Advice\n\n1. **Check for Allocation Success**: Always check if `malloc` returns a non-null pointer before using the allocated memory.\n2. **Use `sizeof` Correctly**: Ensure that `sizeof` is used with the correct type or object to allocate the appropriate amount of memory.\n3. **Initialize Allocated Memory**: Consider using `calloc` instead of `malloc` to initialize the allocated memory to zero.\n4. **Free Allocated Memory**: Ensure that all dynamically allocated memory is freed when no longer needed to prevent memory leaks.\n5. **Use Smart Pointers**: In C++, prefer using smart pointers (e.g., `std::unique_ptr`, `std::shared_ptr`) to manage dynamic memory automatically.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib> // for malloc and free\n#include <iostream>\n\n// Assuming aocl_post_op_matrix_mul is a struct or class\nstruct aocl_post_op_matrix_mul {\n    // Members of the struct\n};\n\nint main() {\n    // Allocate memory for aocl_post_op_matrix_mul\n    aocl_post_op_matrix_mul* ptr = static_cast<aocl_post_op_matrix_mul*>(malloc(sizeof(aocl_post_op_matrix_mul)));\n    \n    // Check if allocation was successful\n    if (ptr == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    // Use the allocated memory\n    // ...\n\n    // Free the allocated memory\n    free(ptr);\n\n    return EXIT_SUCCESS;\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard library is required:\n\n- `<cstdlib>`: Provides the `malloc` and `free` functions.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-401: Improper Release of Memory Before Removing Last Reference ('Memory Leak')](https://cwe.mitre.org/data/definitions/401.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-6b9d4e7f-1bfc-421f-8eb4-b3e6b3207fde",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Identified Issue with C Function (malloc)\" vulnerability in C++ typically arises from improper use of the `malloc` function, which is used to allocate memory dynamically. This vulnerability can lead to various issues such as buffer overflows, memory leaks, or undefined behavior if the allocated memory is not properly managed. Specifically, when using `malloc(scale_zp_size)`, if `scale_zp_size` is not correctly calculated or validated, it can result in insufficient memory allocation or excessive memory allocation, leading to potential security risks.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that the value of `scale_zp_size` is validated before being used in `malloc`. It should be a positive integer and within a reasonable range to prevent excessive memory allocation.\n\n2. **Check Return Value**: Always check the return value of `malloc`. If it returns `NULL`, it indicates that the memory allocation failed, and the program should handle this scenario gracefully.\n\n3. **Use Safer Alternatives**: Consider using safer alternatives like `calloc`, which initializes the allocated memory to zero, or smart pointers in C++ that automatically manage memory.\n\n4. **Free Allocated Memory**: Ensure that any memory allocated with `malloc` is properly freed using `free` to prevent memory leaks.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstdlib> // Required for malloc and free\n\nvoid processScaleZpSize(size_t scale_zp_size) {\n    // Validate scale_zp_size\n    if (scale_zp_size == 0 || scale_zp_size > MAX_ALLOWED_SIZE) {\n        std::cerr << \"Invalid scale_zp_size value.\" << std::endl;\n        return;\n    }\n\n    // Allocate memory\n    void* ptr = malloc(scale_zp_size);\n    if (ptr == nullptr) {\n        std::cerr << \"Memory allocation failed.\" << std::endl;\n        return;\n    }\n\n    // Use the allocated memory\n    // ...\n\n    // Free the allocated memory\n    free(ptr);\n}\n\nint main() {\n    size_t scale_zp_size = 1024; // Example size\n    processScaleZpSize(scale_zp_size);\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<cstdlib>`: For `malloc` and `free` functions.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-911932c6-bb03-4ba1-9a79-feba4789cb9c",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ typically arises from improper use of the `malloc` function, which is used to allocate memory dynamically. In the provided code snippet, `malloc(sizeof(aocl_post_op_matrix_add))` is used, which can lead to several issues if not handled correctly:\n\n1. **Incorrect Size Calculation**: If `aocl_post_op_matrix_add` is a type or a structure, `sizeof` should correctly calculate the size. However, if `aocl_post_op_matrix_add` is a pointer or an array, this could lead to incorrect memory allocation.\n\n2. **Memory Leak**: If the allocated memory is not freed after use, it can lead to memory leaks.\n\n3. **Null Pointer Dereference**: If `malloc` fails, it returns a null pointer. If this is not checked, dereferencing a null pointer can lead to undefined behavior.\n\n### General Mitigation Advice\n\n- **Check for Null Pointers**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n- **Free Allocated Memory**: Ensure that all dynamically allocated memory is freed when it is no longer needed.\n- **Use `sizeof` Correctly**: Ensure that `sizeof` is used on the correct type to allocate the appropriate amount of memory.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib> // Required for malloc and free\n#include <iostream>\n\n// Assuming aocl_post_op_matrix_add is a struct\nstruct aocl_post_op_matrix_add {\n    // Structure members\n};\n\nint main() {\n    // Allocate memory for aocl_post_op_matrix_add\n    aocl_post_op_matrix_add* ptr = (aocl_post_op_matrix_add*)malloc(sizeof(aocl_post_op_matrix_add));\n    \n    // Check if malloc was successful\n    if (ptr == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1; // Exit or handle error appropriately\n    }\n\n    // Use the allocated memory\n    // ...\n\n    // Free the allocated memory\n    free(ptr);\n    ptr = nullptr; // Avoid dangling pointer\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstdlib>`: This library is required for using `malloc` and `free`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n\nThese links were verified to be active and accessible for anonymous users."
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-2d2edb79-c086-4129-bf1b-61e9d4d43737",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, leading to potential memory allocation issues. Specifically, using `malloc(sizeof(aocl_post_op))` can be problematic if `aocl_post_op` is a type rather than an instance, as `sizeof` will return the size of the type, which may not be the intended size for allocation. This can lead to buffer overflows, memory corruption, or undefined behavior if the allocated memory is not sufficient for the intended use.\n\n### General Mitigation Advice\n\n1. **Use `sizeof` Correctly**: Ensure that `sizeof` is used with an instance of the type or the type itself, depending on the context.\n2. **Check Return Values**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Use Safer Alternatives**: Consider using `new` in C++ for memory allocation, which provides type safety and automatically calls constructors.\n4. **Initialize Allocated Memory**: Use functions like `calloc` or explicitly initialize memory to avoid using uninitialized memory.\n5. **Free Allocated Memory**: Ensure that all dynamically allocated memory is freed to prevent memory leaks.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib> // Required for malloc and free\n\n// Assuming aocl_post_op is a type\nstruct aocl_post_op {\n    // Members of the struct\n};\n\nint main() {\n    // Correct usage of malloc with sizeof\n    aocl_post_op* post_op = (aocl_post_op*)malloc(sizeof(aocl_post_op));\n    if (post_op == nullptr) {\n        // Handle allocation failure\n        return -1;\n    }\n\n    // Use the allocated memory\n\n    // Free the allocated memory\n    free(post_op);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstdlib>`: This library is required for using `malloc` and `free`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-dc7fb73c-6045-4fd2-9d1d-56dc7b677766",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question is related to the use of the `memcpy` function in C++. The `memcpy` function is used to copy a block of memory from one location to another. However, if not used carefully, it can lead to buffer overflow vulnerabilities. This occurs when the destination buffer is not large enough to hold the data being copied, potentially leading to memory corruption, crashes, or security vulnerabilities such as arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Always ensure that the destination buffer is large enough to accommodate the data being copied. This can be done by performing explicit bounds checking before calling `memcpy`.\n\n2. **Use Safer Alternatives**: Consider using safer alternatives like `std::copy` or `std::memmove` if overlapping memory regions are involved.\n\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows in your code.\n\n4. **Code Reviews**: Regularly perform code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo mitigate the vulnerability in the provided code snippet, ensure that the destination buffer is large enough to hold the data being copied. Here is a revised version of the code with added bounds checking:\n\n```cpp\n#include <cstring>  // For memcpy\n#include <algorithm> // For std::min\n\n// Assuming dst_iter_ and dst_layer_ are properly defined and initialized\nvoid safe_memcpy(char* dst_iter_, const char* dst_layer_, size_t dst_iter_ld, size_t dst_layer_ld, size_t block_step, size_t dst_iter_size) {\n    for (size_t i = 0; i < dst_iter_size / dst_iter_ld; ++i) {\n        // Ensure that the destination buffer is large enough\n        size_t copy_size = std::min(block_step, dst_iter_size - i * dst_iter_ld);\n        std::memcpy(dst_iter_ + i * dst_iter_ld, dst_layer_ + i * dst_layer_ld, copy_size);\n    }\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard library headers are required:\n\n- `<cstring>`: Provides the `memcpy` function.\n- `<algorithm>`: Provides the `std::min` function.\n\n### Relevant Resources\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-8e067d85-ae52-4a0a-9bb0-eddaef788b69",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question is related to the use of the `memcpy` function in C++. The `memcpy` function is used to copy a block of memory from one location to another. However, if not used carefully, it can lead to buffer overflow vulnerabilities. This occurs when the destination buffer is not large enough to hold the data being copied, potentially leading to memory corruption, crashes, or security vulnerabilities such as arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Always ensure that the destination buffer is large enough to accommodate the data being copied. This can be done by performing explicit bounds checking before calling `memcpy`.\n\n2. **Use Safer Alternatives**: Consider using safer alternatives like `std::copy` or `std::memmove` if overlapping memory regions are involved.\n\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows in your code.\n\n4. **Code Reviews**: Regularly perform code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo mitigate the vulnerability in the provided code snippet, ensure that the destination buffer is large enough to hold the data being copied. Here is a revised version of the code with added bounds checking:\n\n```cpp\n#include <cstring>  // For memcpy\n#include <algorithm> // For std::min\n\n// Assuming dst_iter_ and dst_layer_ are properly defined and initialized\nvoid safe_memcpy(char* dst_iter_, const char* dst_layer_, size_t dst_iter_ld, size_t dst_layer_ld, size_t block_step, size_t dst_iter_size) {\n    for (size_t i = 0; i < dst_iter_size / dst_iter_ld; ++i) {\n        // Ensure that the destination buffer is large enough\n        size_t copy_size = std::min(block_step, dst_iter_size - i * dst_iter_ld);\n        std::memcpy(dst_iter_ + i * dst_iter_ld, dst_layer_ + i * dst_layer_ld, copy_size);\n    }\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard library headers are required:\n\n- `<cstring>`: Provides the `memcpy` function.\n- `<algorithm>`: Provides the `std::min` function.\n\n### Relevant Resources\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-5adbc8aa-bfd8-4c33-8f19-cef70c44d2b3",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ typically arises from improper use of the `malloc` function, which is used to allocate memory dynamically. In the specific case of `malloc(sizeof(aocl_pre_op_sf))`, the vulnerability may occur if `aocl_pre_op_sf` is not a type but rather a variable or an expression, leading to incorrect memory allocation size. This can result in buffer overflows, memory corruption, or undefined behavior.\n\n### General Mitigation Advice\n\n1. **Ensure Correct Size Calculation**: Always use `sizeof` with the type, not the variable, to ensure the correct amount of memory is allocated.\n2. **Check for NULL**: Always check the return value of `malloc` for `NULL` to handle memory allocation failures gracefully.\n3. **Use Safer Alternatives**: Consider using `new` in C++ for memory allocation, which throws an exception on failure, or use smart pointers like `std::unique_ptr` or `std::shared_ptr` to manage memory automatically.\n4. **Initialize Allocated Memory**: Use functions like `calloc` or `memset` to initialize allocated memory to prevent undefined behavior from uninitialized memory access.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>  // For malloc and free\n#include <cstring>  // For memset\n\n// Assuming aocl_pre_op_sf is a type\ntypedef struct {\n    // Structure members\n} aocl_pre_op_sf;\n\nint main() {\n    // Correct usage of malloc with sizeof(type)\n    aocl_pre_op_sf* ptr = (aocl_pre_op_sf*)malloc(sizeof(aocl_pre_op_sf));\n    \n    if (ptr == NULL) {\n        // Handle memory allocation failure\n        return -1;\n    }\n\n    // Initialize allocated memory\n    memset(ptr, 0, sizeof(aocl_pre_op_sf));\n\n    // Use the allocated memory\n\n    // Free the allocated memory\n    free(ptr);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<cstring>`: Required for `memset`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-af5ef9b5-3c8f-4188-819d-6561afdfef40",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, leading to potential memory allocation issues such as buffer overflows, memory leaks, or undefined behavior. This vulnerability typically occurs when the size parameter passed to `malloc` is incorrect, unchecked, or derived from untrusted sources, which can result in insufficient memory allocation or excessive memory consumption.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate input sizes before using them in memory allocation functions.\n2. **Use Safer Alternatives**: Consider using C++ memory management features like `new` and `delete` or smart pointers (`std::unique_ptr`, `std::shared_ptr`) which provide automatic memory management.\n3. **Check Return Values**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n4. **Limit Memory Usage**: Implement limits on the amount of memory that can be allocated to prevent excessive memory consumption.\n5. **Free Allocated Memory**: Ensure that all allocated memory is properly freed to prevent memory leaks.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstdlib> // Required for malloc and free\n\nint main() {\n    size_t size = 10; // Example size, should be validated\n    if (size <= 0 || size > MAX_ALLOWED_SIZE) { // Validate size\n        std::cerr << \"Invalid size for memory allocation.\" << std::endl;\n        return 1;\n    }\n\n    int* ptr = (int*)malloc(size * sizeof(int));\n    if (ptr == nullptr) { // Check if malloc succeeded\n        std::cerr << \"Memory allocation failed.\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n    for (size_t i = 0; i < size; ++i) {\n        ptr[i] = i;\n    }\n\n    // Free the allocated memory\n    free(ptr);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<cstdlib>`: For `malloc` and `free` functions.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)\n\nThese links are verified to be active and accessible to anonymous users."
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-7464485c-1996-4cef-81f8-9edd52cf702f",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ typically arises from improper use of the `malloc` function, which is used to allocate memory dynamically. In the specific case of `malloc(sizeof(aocl_pre_op_sf))`, the vulnerability may occur if `aocl_pre_op_sf` is not a type but rather a variable or an expression, leading to incorrect memory allocation size. This can result in buffer overflows, memory corruption, or undefined behavior.\n\n### General Mitigation Advice\n\n1. **Ensure Correct Size Calculation**: Always use `sizeof` with the type, not the variable, to ensure the correct amount of memory is allocated.\n2. **Check for NULL**: Always check the return value of `malloc` for `NULL` to handle memory allocation failures gracefully.\n3. **Use Safer Alternatives**: Consider using `new` in C++ for memory allocation, which throws an exception on failure, or use smart pointers like `std::unique_ptr` or `std::shared_ptr` to manage memory automatically.\n4. **Initialize Allocated Memory**: Use functions like `calloc` or `memset` to initialize allocated memory to prevent undefined behavior from uninitialized memory access.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>  // For malloc and free\n#include <cstring>  // For memset\n\n// Assuming aocl_pre_op_sf is a type\ntypedef struct {\n    // Structure members\n} aocl_pre_op_sf;\n\nint main() {\n    // Correct usage of malloc with sizeof(type)\n    aocl_pre_op_sf* ptr = (aocl_pre_op_sf*)malloc(sizeof(aocl_pre_op_sf));\n    \n    if (ptr == NULL) {\n        // Handle memory allocation failure\n        return -1;\n    }\n\n    // Initialize allocated memory\n    memset(ptr, 0, sizeof(aocl_pre_op_sf));\n\n    // Use the allocated memory\n\n    // Free the allocated memory\n    free(ptr);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<cstring>`: Required for `memset`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-caf7406e-66fc-40ae-8eac-20a2d55b486d",
              "help": {
                "text": "",
                "markdown": "### Detected Issue with C Function (malloc) Vulnerability in C++\n\nThe vulnerability arises from the improper use of the `malloc` function in C++, specifically when allocating memory for a structure or object. The code snippet `malloc(sizeof(aocl_pre_op))` is problematic because it does not account for the actual size of the data structure or object being allocated. This can lead to buffer overflows, memory corruption, or undefined behavior if the size of `aocl_pre_op` is not correctly calculated.\n\n### General Mitigation Advice\n\n1. **Use `new` Operator**: In C++, prefer using the `new` operator for memory allocation, which automatically calculates the size of the object.\n2. **Check Return Values**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Use `sizeof` Correctly**: Ensure that `sizeof` is used with the correct type or object to allocate the appropriate amount of memory.\n4. **Initialize Allocated Memory**: Consider using `calloc` instead of `malloc` if you need the allocated memory to be initialized to zero.\n5. **Free Allocated Memory**: Always free the allocated memory using `free` to prevent memory leaks.\n\n### Source Code Fix Recommendation\n\nReplace the `malloc` call with the `new` operator in C++:\n\n```cpp\n// Original code\naocl_pre_op* ptr = (aocl_pre_op*)malloc(sizeof(aocl_pre_op));\n\n// Fixed code using new operator\naocl_pre_op* ptr = new aocl_pre_op;\n\n// Ensure to delete the allocated memory when done\ndelete ptr;\n```\n\n### Library Dependencies\n\nThe code example provided does not require any additional library dependencies beyond the standard C++ libraries. Ensure that you include the necessary headers for your specific use case, such as `<cstdlib>` for `malloc` and `<new>` for `new`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)\n\nThese links are verified to be active and accessible for anonymous users."
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-14df1c41-c489-4d47-8cdd-0e261fa239de",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ programming arises when the `malloc` function is used incorrectly, potentially leading to memory allocation issues such as buffer overflows, memory leaks, or undefined behavior. In the specific case of `malloc(sizeof(float))`, the vulnerability may occur if the allocated memory is insufficient for the intended use, or if the allocation is not properly checked for success, leading to potential dereferencing of a null pointer.\n\n### General Mitigation Advice\n\n1. **Check for Allocation Success**: Always verify that the memory allocation was successful by checking if the returned pointer is not `NULL`.\n2. **Use `new` in C++**: Prefer using `new` and `delete` in C++ for memory management, as they provide better type safety and integration with C++ object semantics.\n3. **Proper Size Calculation**: Ensure that the size passed to `malloc` is correct and accounts for the number of elements and their type.\n4. **Free Allocated Memory**: Always free the allocated memory when it is no longer needed to prevent memory leaks.\n\n### Source Code Fix Recommendation\n\nHere is a corrected version of the code using `new` instead of `malloc`:\n\n```cpp\n#include <iostream>\n\nint main() {\n    // Allocate memory for a single float\n    float* ptr = new (std::nothrow) float;\n    \n    // Check if allocation was successful\n    if (ptr == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n    *ptr = 3.14f;\n    std::cout << \"Value: \" << *ptr << std::endl;\n\n    // Free the allocated memory\n    delete ptr;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nThe above code example requires the following standard library:\n\n- `<iostream>`: For input and output operations.\n\n### Relevant Links\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "glog-17c14b6e-ea66-4f79-b732-e1ae015d6eea",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/xbyak/xbyak_util.h"
                },
                "region": {
                  "startLine": 999,
                  "startColumn": 4,
                  "endLine": 999,
                  "endColumn": 11,
                  "charOffset": 31987,
                  "charLength": 7,
                  "snippet": {
                    "text": "fprintf",
                    "rendered": {
                      "text": "fprintf",
                      "markdown": "`fprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-9cbdc0c8-0b17-40eb-860e-a3fedc7ed33e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/xbyak/xbyak_util.h"
                },
                "region": {
                  "startLine": 997,
                  "startColumn": 33,
                  "endLine": 997,
                  "endColumn": 48,
                  "charOffset": 31930,
                  "charLength": 15,
                  "snippet": {
                    "text": "strlen(suffix_)",
                    "rendered": {
                      "text": "strlen(suffix_)",
                      "markdown": "`strlen(suffix_)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/cpu/x64/xbyak/xbyak_util.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 31930,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strlen_s(suffix_, <size of suffix_>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/cpu/x64/xbyak/xbyak_util.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 31930,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strnlen(suffix_, <size of suffix_>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b0086ef9-f35a-4bfe-ab74-c0953f60a28a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/xbyak/xbyak_util.h"
                },
                "region": {
                  "startLine": 961,
                  "startColumn": 4,
                  "endLine": 961,
                  "endColumn": 11,
                  "charOffset": 31137,
                  "charLength": 7,
                  "snippet": {
                    "text": "fprintf",
                    "rendered": {
                      "text": "fprintf",
                      "markdown": "`fprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-4b74496e-3ccd-4368-868d-dbbc936d7e8f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/xbyak/xbyak_util.h"
                },
                "region": {
                  "startLine": 950,
                  "startColumn": 5,
                  "endLine": 950,
                  "endColumn": 12,
                  "charOffset": 30861,
                  "charLength": 7,
                  "snippet": {
                    "text": "fprintf",
                    "rendered": {
                      "text": "fprintf",
                      "markdown": "`fprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-7d8b12ef-3d91-42f0-bc3a-a9d16e9fea1e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/xbyak/xbyak_util.h"
                },
                "region": {
                  "startLine": 997,
                  "startColumn": 14,
                  "endLine": 997,
                  "endColumn": 30,
                  "charOffset": 31911,
                  "charLength": 16,
                  "snippet": {
                    "text": "strlen(funcName)",
                    "rendered": {
                      "text": "strlen(funcName)",
                      "markdown": "`strlen(funcName)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/cpu/x64/xbyak/xbyak_util.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 31911,
                        "charLength": 16
                      },
                      "insertedContent": {
                        "text": "strlen_s(funcName, <size of funcName>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/cpu/x64/xbyak/xbyak_util.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 31911,
                        "charLength": 16
                      },
                      "insertedContent": {
                        "text": "strnlen(funcName, <size of funcName>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d9755b07-21ec-4f0e-b172-e15e089aa84d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/xbyak/xbyak_util.h"
                },
                "region": {
                  "startLine": 1001,
                  "startColumn": 3,
                  "endLine": 1001,
                  "endColumn": 10,
                  "charOffset": 32014,
                  "charLength": 7,
                  "snippet": {
                    "text": "fprintf",
                    "rendered": {
                      "text": "fprintf",
                      "markdown": "`fprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-3db8901c-5cf5-4fec-b0c5-0413b0d55aed",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/xbyak/xbyak_util.h"
                },
                "region": {
                  "startLine": 992,
                  "startColumn": 3,
                  "endLine": 992,
                  "endColumn": 10,
                  "charOffset": 31681,
                  "charLength": 7,
                  "snippet": {
                    "text": "fprintf",
                    "rendered": {
                      "text": "fprintf",
                      "markdown": "`fprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-3ad6750d-581a-441f-bc3f-fd5d875ff97a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/xbyak/xbyak_util.h"
                },
                "region": {
                  "startLine": 948,
                  "startColumn": 10,
                  "endLine": 948,
                  "endColumn": 15,
                  "charOffset": 30817,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-150ed5ca-d8de-49a0-9409-a0faf7bd22e0",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/xbyak/xbyak_util.h"
                },
                "region": {
                  "startLine": 748,
                  "startColumn": 3,
                  "endLine": 748,
                  "endColumn": 10,
                  "charOffset": 26033,
                  "charLength": 7,
                  "snippet": {
                    "text": "fprintf",
                    "rendered": {
                      "text": "fprintf",
                      "markdown": "`fprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-601b03cf-3e19-4ca8-ae41-abc365dbfbf2",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/xbyak/xbyak_util.h"
                },
                "region": {
                  "startLine": 763,
                  "startColumn": 2,
                  "endLine": 763,
                  "endColumn": 8,
                  "charOffset": 26382,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ca795548-4f6b-4528-9296-5974165f64ac",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/xbyak/xbyak_util.h"
                },
                "region": {
                  "startLine": 761,
                  "startColumn": 3,
                  "endLine": 761,
                  "endColumn": 9,
                  "charOffset": 26340,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5d6f7bb0-0895-4790-8d2f-11e6e2267bb4",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/xbyak/xbyak_util.h"
                },
                "region": {
                  "startLine": 735,
                  "startColumn": 3,
                  "endLine": 735,
                  "endColumn": 10,
                  "charOffset": 25709,
                  "charLength": 7,
                  "snippet": {
                    "text": "fprintf",
                    "rendered": {
                      "text": "fprintf",
                      "markdown": "`fprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-2c684bd2-7397-49f9-99ea-eba24066b671",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/xbyak/xbyak_util.h"
                },
                "region": {
                  "startLine": 724,
                  "startColumn": 3,
                  "endLine": 724,
                  "endColumn": 10,
                  "charOffset": 25472,
                  "charLength": 7,
                  "snippet": {
                    "text": "fprintf",
                    "rendered": {
                      "text": "fprintf",
                      "markdown": "`fprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-07d92295-9f2e-464b-855e-2ba2b506b31c",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/xbyak/xbyak_util.h"
                },
                "region": {
                  "startLine": 608,
                  "startColumn": 9,
                  "endLine": 608,
                  "endColumn": 12,
                  "charOffset": 21222,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-bf911ed7-bb82-414d-a7c0-a98b971e0eb6",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/xbyak/xbyak_util.h"
                },
                "region": {
                  "startLine": 606,
                  "startColumn": 8,
                  "endLine": 606,
                  "endColumn": 11,
                  "charOffset": 21148,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-03e3286f-1c48-49e1-ab3f-6f161d7b9b89",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/xbyak/xbyak_util.h"
                },
                "region": {
                  "startLine": 588,
                  "startColumn": 36,
                  "endLine": 588,
                  "endColumn": 39,
                  "charOffset": 20425,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-5eb721b7-0ad3-4141-ba9d-09cbf9882eb6",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/xbyak/xbyak_util.h"
                },
                "region": {
                  "startLine": 520,
                  "startColumn": 6,
                  "endLine": 520,
                  "endColumn": 9,
                  "charOffset": 17960,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-167c27f1-d1a2-4b58-a17c-091aff425e98",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/xbyak/xbyak_util.h"
                },
                "region": {
                  "startLine": 497,
                  "startColumn": 30,
                  "endLine": 497,
                  "endColumn": 33,
                  "charOffset": 17426,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-c359dd80-15a4-4591-87b6-c36f22eb62a5",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/xbyak/xbyak_util.h"
                },
                "region": {
                  "startLine": 492,
                  "startColumn": 22,
                  "endLine": 492,
                  "endColumn": 25,
                  "charOffset": 17249,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-042c6638-4a8a-4aee-9e57-3d933fe288b0",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/xbyak/xbyak_util.h"
                },
                "region": {
                  "startLine": 715,
                  "startColumn": 3,
                  "endLine": 715,
                  "endColumn": 10,
                  "charOffset": 25265,
                  "charLength": 7,
                  "snippet": {
                    "text": "fprintf",
                    "rendered": {
                      "text": "fprintf",
                      "markdown": "`fprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-492ad4a3-32e2-467f-a661-89e9c9b6ce6e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/xbyak/xbyak_util.h"
                },
                "region": {
                  "startLine": 621,
                  "startColumn": 2,
                  "endLine": 621,
                  "endColumn": 8,
                  "charOffset": 21517,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5caf50e3-e17b-402f-b3ec-d3239ef7790f",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/xbyak/xbyak.h"
                },
                "region": {
                  "startLine": 2837,
                  "startColumn": 48,
                  "endLine": 2837,
                  "endColumn": 51,
                  "charOffset": 93880,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-894ce6f7-9681-42eb-9c72-358e401fbce3",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/xbyak/xbyak_util.h"
                },
                "region": {
                  "startLine": 619,
                  "startColumn": 2,
                  "endLine": 619,
                  "endColumn": 8,
                  "charOffset": 21393,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-38abd51b-8bb3-4bfc-bf62-8836447eb19d",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/xbyak/xbyak.h"
                },
                "region": {
                  "startLine": 2691,
                  "startColumn": 17,
                  "endLine": 2691,
                  "endColumn": 20,
                  "charOffset": 87248,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-636e6e56-2566-4542-8714-5fe967967bb3",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/xbyak/xbyak.h"
                },
                "region": {
                  "startLine": 2815,
                  "startColumn": 50,
                  "endLine": 2815,
                  "endColumn": 57,
                  "charOffset": 93043,
                  "charLength": 7,
                  "snippet": {
                    "text": "fprintf",
                    "rendered": {
                      "text": "fprintf",
                      "markdown": "`fprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-4d399260-df19-41cd-9d17-16f52d337244",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/xbyak/xbyak.h"
                },
                "region": {
                  "startLine": 1146,
                  "startColumn": 5,
                  "endLine": 1146,
                  "endColumn": 11,
                  "charOffset": 35073,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-189e9745-7801-4b54-b368-714eb06c1984",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/xbyak/xbyak.h"
                },
                "region": {
                  "startLine": 524,
                  "startColumn": 2,
                  "endLine": 524,
                  "endColumn": 5,
                  "charOffset": 14302,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-1cac75f2-57b5-49b2-bfad-e74fa963292d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/stack_checker.hpp"
                },
                "region": {
                  "startLine": 294,
                  "startColumn": 12,
                  "endLine": 294,
                  "endColumn": 18,
                  "charOffset": 11021,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-dd0da790-0bb7-4e0f-a95d-876d13fffd5b",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Weak/Broken Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/xbyak/xbyak_mnemonic.h"
                },
                "region": {
                  "startLine": 821,
                  "startColumn": 5,
                  "endLine": 821,
                  "endColumn": 9,
                  "charOffset": 67279,
                  "charLength": 4,
                  "snippet": {
                    "text": "sha1",
                    "rendered": {
                      "text": "sha1",
                      "markdown": "`sha1`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/cpu/x64/xbyak/xbyak_mnemonic.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 67279,
                        "charLength": 4
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/cpu/x64/xbyak/xbyak_mnemonic.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 67279,
                        "charLength": 4
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "glog-cfc00688-6ef4-4a58-b622-cd01133c7957",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/stack_checker.hpp"
                },
                "region": {
                  "startLine": 229,
                  "startColumn": 16,
                  "endLine": 229,
                  "endColumn": 22,
                  "charOffset": 8412,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-295a35ef-f221-463b-b677-a1ec9a39cc2d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/xbyak/xbyak.h"
                },
                "region": {
                  "startLine": 1211,
                  "startColumn": 24,
                  "endLine": 1211,
                  "endColumn": 31,
                  "charOffset": 37022,
                  "charLength": 7,
                  "snippet": {
                    "text": "fprintf",
                    "rendered": {
                      "text": "fprintf",
                      "markdown": "`fprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-775275e5-2400-42fb-ba21-367e4293f854",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Weak/Broken Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/xbyak/xbyak_mnemonic.h"
                },
                "region": {
                  "startLine": 820,
                  "startColumn": 5,
                  "endLine": 820,
                  "endColumn": 9,
                  "charOffset": 67169,
                  "charLength": 4,
                  "snippet": {
                    "text": "sha1",
                    "rendered": {
                      "text": "sha1",
                      "markdown": "`sha1`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/cpu/x64/xbyak/xbyak_mnemonic.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 67169,
                        "charLength": 4
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/cpu/x64/xbyak/xbyak_mnemonic.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 67169,
                        "charLength": 4
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "glog-79425fd9-f3fa-4812-8313-3dcb181f7cea",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Weak/Broken Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/xbyak/xbyak_mnemonic.h"
                },
                "region": {
                  "startLine": 818,
                  "startColumn": 5,
                  "endLine": 818,
                  "endColumn": 9,
                  "charOffset": 66951,
                  "charLength": 4,
                  "snippet": {
                    "text": "sha1",
                    "rendered": {
                      "text": "sha1",
                      "markdown": "`sha1`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/cpu/x64/xbyak/xbyak_mnemonic.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 66951,
                        "charLength": 4
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/cpu/x64/xbyak/xbyak_mnemonic.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 66951,
                        "charLength": 4
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "glog-9b234118-42da-44e6-bf0f-305c51f4daa1",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/jit_uni_reorder.cpp"
                },
                "region": {
                  "startLine": 2474,
                  "startColumn": 8,
                  "endLine": 2474,
                  "endColumn": 14,
                  "charOffset": 98273,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-754c6576-8c10-43c3-9f79-05e44aded80f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/jit_uni_reorder.cpp"
                },
                "region": {
                  "startLine": 2287,
                  "startColumn": 8,
                  "endLine": 2287,
                  "endColumn": 14,
                  "charOffset": 90375,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5d07d9bc-17d7-494c-91f4-25ce39a32492",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Weak/Broken Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/xbyak/xbyak_mnemonic.h"
                },
                "region": {
                  "startLine": 819,
                  "startColumn": 5,
                  "endLine": 819,
                  "endColumn": 9,
                  "charOffset": 67060,
                  "charLength": 4,
                  "snippet": {
                    "text": "sha1",
                    "rendered": {
                      "text": "sha1",
                      "markdown": "`sha1`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/cpu/x64/xbyak/xbyak_mnemonic.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 67060,
                        "charLength": 4
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/cpu/x64/xbyak/xbyak_mnemonic.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 67060,
                        "charLength": 4
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "glog-b2cb9f17-1111-4167-989a-dd482cab4ffd",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/jit_uni_reorder.cpp"
                },
                "region": {
                  "startLine": 2283,
                  "startColumn": 8,
                  "endLine": 2283,
                  "endColumn": 14,
                  "charOffset": 90291,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-3e50c5eb-6f1d-4384-a03c-5dfa5b251e16",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/jit_uni_reorder.cpp"
                },
                "region": {
                  "startLine": 2083,
                  "startColumn": 8,
                  "endLine": 2083,
                  "endColumn": 14,
                  "charOffset": 82074,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-88aa85cb-ff57-44b9-a33a-98d4c1aa8941",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/jit_uni_reorder.cpp"
                },
                "region": {
                  "startLine": 2063,
                  "startColumn": 8,
                  "endLine": 2063,
                  "endColumn": 14,
                  "charOffset": 81456,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c457f927-12b0-4b50-b205-11fd210ca24d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/jit_uni_reorder_utils.cpp"
                },
                "region": {
                  "startLine": 601,
                  "startColumn": 4,
                  "endLine": 601,
                  "endColumn": 10,
                  "charOffset": 21875,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e528ff3e-e333-400e-8de5-f887f14689ae",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/jit_uni_reorder_utils.cpp"
                },
                "region": {
                  "startLine": 593,
                  "startColumn": 4,
                  "endLine": 593,
                  "endColumn": 10,
                  "charOffset": 21418,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-772ae528-357a-4f00-9096-ec1454f8540b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/jit_uni_reorder_utils.cpp"
                },
                "region": {
                  "startLine": 435,
                  "startColumn": 8,
                  "endLine": 435,
                  "endColumn": 14,
                  "charOffset": 15922,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-83476265-fbdc-483f-9e42-89057908dffa",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/jit_uni_reorder.cpp"
                },
                "region": {
                  "startLine": 2020,
                  "startColumn": 12,
                  "endLine": 2020,
                  "endColumn": 18,
                  "charOffset": 79887,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-76b37440-f09f-47fc-9a61-027b09306d6f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/jit_uni_reorder.cpp"
                },
                "region": {
                  "startLine": 2018,
                  "startColumn": 12,
                  "endLine": 2018,
                  "endColumn": 18,
                  "charOffset": 79829,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-27812892-05c9-406e-9df6-46cd2452917f",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/gemm_bf16_inner_product.cpp"
                },
                "region": {
                  "startLine": 273,
                  "startColumn": 23,
                  "endLine": 273,
                  "endColumn": 26,
                  "charOffset": 10574,
                  "charLength": 3,
                  "snippet": {
                    "text": "OCB",
                    "rendered": {
                      "text": "OCB",
                      "markdown": "`OCB`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-d5ae64ab-4b9c-42c8-bbcc-9d4e47f6bccc",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/gemm_bf16_inner_product.cpp"
                },
                "region": {
                  "startLine": 239,
                  "startColumn": 23,
                  "endLine": 239,
                  "endColumn": 26,
                  "charOffset": 9331,
                  "charLength": 3,
                  "snippet": {
                    "text": "OCB",
                    "rendered": {
                      "text": "OCB",
                      "markdown": "`OCB`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-ecbbdb1b-84ed-4dea-9641-9a4bb3188cf5",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/gemm_bf16_inner_product.cpp"
                },
                "region": {
                  "startLine": 220,
                  "startColumn": 16,
                  "endLine": 220,
                  "endColumn": 19,
                  "charOffset": 8578,
                  "charLength": 3,
                  "snippet": {
                    "text": "OCB",
                    "rendered": {
                      "text": "OCB",
                      "markdown": "`OCB`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-0183d426-fa9a-4b93-8732-82a145ba47db",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/jit_uni_reorder_utils.cpp"
                },
                "region": {
                  "startLine": 596,
                  "startColumn": 8,
                  "endLine": 596,
                  "endColumn": 14,
                  "charOffset": 21569,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-83b859a4-9123-4f10-ae66-1faae262bacc",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/jit_uni_reorder_utils.cpp"
                },
                "region": {
                  "startLine": 424,
                  "startColumn": 8,
                  "endLine": 424,
                  "endColumn": 14,
                  "charOffset": 15642,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-89493fc8-68e9-4faf-804b-2c40a88a48a4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/zendnn_matmul_gemm.cpp"
                },
                "region": {
                  "startLine": 143,
                  "startColumn": 51,
                  "endLine": 144,
                  "endColumn": 51,
                  "charOffset": 4779,
                  "charLength": 66,
                  "snippet": {
                    "text": "malloc(sizeof(\n                                 aocl_post_op_bias)",
                    "rendered": {
                      "text": "malloc(sizeof(\n                                 aocl_post_op_bias)",
                      "markdown": "`malloc(sizeof(\n                                 aocl_post_op_bias)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/zendnn_matmul_gemm.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4779,
                        "charLength": 66
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-34d00e9f-a366-4594-ab51-0f85dbf79d38",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/zendnn_matmul_gemm.cpp"
                },
                "region": {
                  "startLine": 152,
                  "startColumn": 57,
                  "endLine": 153,
                  "endColumn": 57,
                  "charOffset": 5106,
                  "charLength": 72,
                  "snippet": {
                    "text": "malloc(sizeof(\n                                    aocl_post_op_eltwise)",
                    "rendered": {
                      "text": "malloc(sizeof(\n                                    aocl_post_op_eltwise)",
                      "markdown": "`malloc(sizeof(\n                                    aocl_post_op_eltwise)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/zendnn_matmul_gemm.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5106,
                        "charLength": 72
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5110c4bb-d689-41a5-ae16-bca755ae020d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/gemm/s8x8s32/jit_avx512_core_gemv_s8x8s32.cpp"
                },
                "region": {
                  "startLine": 145,
                  "startColumn": 27,
                  "endLine": 146,
                  "endColumn": 28,
                  "charOffset": 4554,
                  "charLength": 36,
                  "snippet": {
                    "text": "malloc(\n                (nthr_n - 1)",
                    "rendered": {
                      "text": "malloc(\n                (nthr_n - 1)",
                      "markdown": "`malloc(\n                (nthr_n - 1)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/cpu/x64/gemm/s8x8s32/jit_avx512_core_gemv_s8x8s32.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4554,
                        "charLength": 36
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-105930c4-2103-4ae3-af3d-ec9f63c49cbd",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/jit_uni_reorder_utils.cpp"
                },
                "region": {
                  "startLine": 418,
                  "startColumn": 8,
                  "endLine": 418,
                  "endColumn": 14,
                  "charOffset": 15483,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-02939ac4-37af-4416-9df0-3a8cb7894347",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/zendnn_matmul_auto_tuner.cpp"
                },
                "region": {
                  "startLine": 76,
                  "startColumn": 18,
                  "endLine": 76,
                  "endColumn": 24,
                  "charOffset": 2322,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-dd7d4390-0a3e-4dfe-9134-791da741aa1f",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Weak/Broken Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/verbose.cpp"
                },
                "region": {
                  "startLine": 1098,
                  "startColumn": 10,
                  "endLine": 1098,
                  "endColumn": 13,
                  "charOffset": 33625,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 33625,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 33625,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "glog-889637e8-3184-4563-9bb6-e20a84f34832",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/zendnn_matmul_gemm.cpp"
                },
                "region": {
                  "startLine": 116,
                  "startColumn": 36,
                  "endLine": 116,
                  "endColumn": 63,
                  "charOffset": 3747,
                  "charLength": 27,
                  "snippet": {
                    "text": "malloc(sizeof(aocl_post_op)",
                    "rendered": {
                      "text": "malloc(sizeof(aocl_post_op)",
                      "markdown": "`malloc(sizeof(aocl_post_op)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/zendnn_matmul_gemm.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3747,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f4e3f452-8aee-40a9-b052-edab7a0f64bb",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/zendnn_matmul_gemm.cpp"
                },
                "region": {
                  "startLine": 123,
                  "startColumn": 53,
                  "endLine": 124,
                  "endColumn": 56,
                  "charOffset": 4011,
                  "charLength": 89,
                  "snippet": {
                    "text": "malloc(max_post_ops_seq_length *\n                               sizeof(AOCL_POST_OP_TYPE)",
                    "rendered": {
                      "text": "malloc(max_post_ops_seq_length *\n                               sizeof(AOCL_POST_OP_TYPE)",
                      "markdown": "`malloc(max_post_ops_seq_length *\n                               sizeof(AOCL_POST_OP_TYPE)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/zendnn_matmul_gemm.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4011,
                        "charLength": 89
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-08ac7fc1-b2ad-424e-8e01-0ec660078ab5",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/zendnn_matmul_auto_tuner.cpp"
                },
                "region": {
                  "startLine": 121,
                  "startColumn": 18,
                  "endLine": 121,
                  "endColumn": 24,
                  "charOffset": 3553,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-2719d534-7d61-4f56-b784-bba857d5eb87",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Weak/Broken Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/verbose.cpp"
                },
                "region": {
                  "startLine": 1028,
                  "startColumn": 10,
                  "endLine": 1028,
                  "endColumn": 13,
                  "charOffset": 31702,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 31702,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 31702,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "glog-8d9c5495-a7ad-4b03-9e93-d3cbd52840b0",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Weak/Broken Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/verbose.cpp"
                },
                "region": {
                  "startLine": 1074,
                  "startColumn": 10,
                  "endLine": 1074,
                  "endColumn": 13,
                  "charOffset": 33013,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 33013,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 33013,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "glog-b7697e46-cc72-4a1b-9442-99778ea87ba0",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Weak/Broken Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/verbose.cpp"
                },
                "region": {
                  "startLine": 900,
                  "startColumn": 10,
                  "endLine": 900,
                  "endColumn": 13,
                  "charOffset": 27282,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 27282,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 27282,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "glog-f449af1b-56b0-4530-8fdc-385dcac7cb2c",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Weak/Broken Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/verbose.cpp"
                },
                "region": {
                  "startLine": 882,
                  "startColumn": 40,
                  "endLine": 882,
                  "endColumn": 43,
                  "charOffset": 26741,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 26741,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 26741,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "glog-43d0f931-b8a6-44af-805c-80e21a788f08",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Weak/Broken Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/verbose.cpp"
                },
                "region": {
                  "startLine": 882,
                  "startColumn": 10,
                  "endLine": 882,
                  "endColumn": 13,
                  "charOffset": 26711,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 26711,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 26711,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "glog-b47d5f90-4271-4486-aca7-a9e408d7fd97",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Weak/Broken Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/verbose.cpp"
                },
                "region": {
                  "startLine": 824,
                  "startColumn": 10,
                  "endLine": 824,
                  "endColumn": 13,
                  "charOffset": 24849,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 24849,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 24849,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "glog-c069335a-1ef0-4ad3-81f0-1552f82dd91e",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Weak/Broken Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/verbose.cpp"
                },
                "region": {
                  "startLine": 823,
                  "startColumn": 39,
                  "endLine": 823,
                  "endColumn": 42,
                  "charOffset": 24813,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 24813,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 24813,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "glog-6c6d0c65-eb2f-47a6-9c17-48034400e231",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Weak/Broken Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/verbose.cpp"
                },
                "region": {
                  "startLine": 823,
                  "startColumn": 10,
                  "endLine": 823,
                  "endColumn": 13,
                  "charOffset": 24784,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 24784,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 24784,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "glog-fa0e94cf-f547-4dee-810a-cd6e3166af61",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Weak/Broken Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/verbose.cpp"
                },
                "region": {
                  "startLine": 787,
                  "startColumn": 10,
                  "endLine": 787,
                  "endColumn": 13,
                  "charOffset": 23751,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 23751,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 23751,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "glog-9dd27b01-8c46-4c67-a7d9-8635269003b2",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Weak/Broken Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/verbose.cpp"
                },
                "region": {
                  "startLine": 766,
                  "startColumn": 10,
                  "endLine": 766,
                  "endColumn": 13,
                  "charOffset": 23206,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 23206,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 23206,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "glog-54e13457-710e-4f2d-ba7a-3106a4dd5de5",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Weak/Broken Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/verbose.cpp"
                },
                "region": {
                  "startLine": 1050,
                  "startColumn": 10,
                  "endLine": 1050,
                  "endColumn": 13,
                  "charOffset": 32367,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 32367,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 32367,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "glog-6c51da51-2f09-4e69-8805-1596cb4c9032",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Weak/Broken Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/verbose.cpp"
                },
                "region": {
                  "startLine": 927,
                  "startColumn": 10,
                  "endLine": 927,
                  "endColumn": 13,
                  "charOffset": 27944,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 27944,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 27944,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "glog-af634f68-8e85-4691-b63b-2c68228a4292",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Weak/Broken Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/verbose.cpp"
                },
                "region": {
                  "startLine": 900,
                  "startColumn": 39,
                  "endLine": 900,
                  "endColumn": 42,
                  "charOffset": 27311,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 27311,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 27311,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "glog-62378b18-7b4d-4d26-87c3-9563f9b4285c",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Weak/Broken Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/verbose.cpp"
                },
                "region": {
                  "startLine": 708,
                  "startColumn": 10,
                  "endLine": 708,
                  "endColumn": 13,
                  "charOffset": 21451,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 21451,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 21451,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "glog-ead70edc-e12d-462d-8c11-8760a5d29d43",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Weak/Broken Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/verbose.cpp"
                },
                "region": {
                  "startLine": 738,
                  "startColumn": 10,
                  "endLine": 738,
                  "endColumn": 13,
                  "charOffset": 22429,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 22429,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 22429,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "glog-fecaaaba-e02e-417b-8551-ea7281a6862c",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Weak/Broken Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/verbose.cpp"
                },
                "region": {
                  "startLine": 634,
                  "startColumn": 14,
                  "endLine": 634,
                  "endColumn": 17,
                  "charOffset": 18920,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18920,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18920,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "glog-c3792f33-c821-4d15-916a-302ed603a5a1",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Weak/Broken Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/verbose.cpp"
                },
                "region": {
                  "startLine": 611,
                  "startColumn": 40,
                  "endLine": 611,
                  "endColumn": 43,
                  "charOffset": 18264,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18264,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18264,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "glog-51059bc7-a281-4c4a-a4ab-f4623b4e48f4",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Weak/Broken Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/verbose.cpp"
                },
                "region": {
                  "startLine": 545,
                  "startColumn": 33,
                  "endLine": 545,
                  "endColumn": 36,
                  "charOffset": 16454,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 16454,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 16454,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "glog-e2f45978-40b2-4d59-93bd-ccb1a39b2a77",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Weak/Broken Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/verbose.cpp"
                },
                "region": {
                  "startLine": 611,
                  "startColumn": 10,
                  "endLine": 611,
                  "endColumn": 13,
                  "charOffset": 18234,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18234,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18234,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "glog-25d8a67b-ba95-4604-bb86-b343dbaa0a1d",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Weak/Broken Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/verbose.cpp"
                },
                "region": {
                  "startLine": 387,
                  "startColumn": 15,
                  "endLine": 387,
                  "endColumn": 18,
                  "charOffset": 11050,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11050,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11050,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "glog-64de4cf2-a1a1-4915-a73e-fd9cac1ce796",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Weak/Broken Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/verbose.cpp"
                },
                "region": {
                  "startLine": 383,
                  "startColumn": 12,
                  "endLine": 383,
                  "endColumn": 15,
                  "charOffset": 10919,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10919,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10919,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "glog-e0f70413-9e21-480a-b481-1caa04461972",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Weak/Broken Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/verbose.cpp"
                },
                "region": {
                  "startLine": 365,
                  "startColumn": 12,
                  "endLine": 365,
                  "endColumn": 15,
                  "charOffset": 10481,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10481,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10481,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "glog-786f8257-87de-4b1e-9d1b-469dd2afe3cb",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Weak/Broken Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/verbose.cpp"
                },
                "region": {
                  "startLine": 349,
                  "startColumn": 10,
                  "endLine": 349,
                  "endColumn": 13,
                  "charOffset": 10030,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10030,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10030,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "glog-36bb949b-bd27-49aa-9934-31c0816cd604",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Weak/Broken Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/verbose.cpp"
                },
                "region": {
                  "startLine": 593,
                  "startColumn": 10,
                  "endLine": 593,
                  "endColumn": 13,
                  "charOffset": 17699,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17699,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17699,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "glog-32b0e464-1783-4438-91cc-fe770afc6421",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Weak/Broken Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/verbose.cpp"
                },
                "region": {
                  "startLine": 339,
                  "startColumn": 14,
                  "endLine": 339,
                  "endColumn": 17,
                  "charOffset": 9812,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9812,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9812,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "glog-30425692-3738-4a7e-916d-9ed892ef08b0",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Weak/Broken Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/verbose.cpp"
                },
                "region": {
                  "startLine": 315,
                  "startColumn": 12,
                  "endLine": 315,
                  "endColumn": 15,
                  "charOffset": 9051,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9051,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9051,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "glog-9d9545a1-494c-4cf9-b14c-344a1711fc71",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/verbose.cpp"
                },
                "region": {
                  "startLine": 123,
                  "startColumn": 8,
                  "endLine": 123,
                  "endColumn": 14,
                  "charOffset": 3909,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-76dcabdd-9d64-49c5-a15a-fc52dd219934",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/verbose.cpp"
                },
                "region": {
                  "startLine": 122,
                  "startColumn": 8,
                  "endLine": 122,
                  "endColumn": 14,
                  "charOffset": 3855,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-fc60d20a-6b65-4945-b87e-8f5c7c00efbf",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/verbose.cpp"
                },
                "region": {
                  "startLine": 116,
                  "startColumn": 8,
                  "endLine": 116,
                  "endColumn": 14,
                  "charOffset": 3572,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-7633b450-1674-49f1-9221-f3b2f09aa390",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/verbose.cpp"
                },
                "region": {
                  "startLine": 117,
                  "startColumn": 8,
                  "endLine": 117,
                  "endColumn": 14,
                  "charOffset": 3647,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-291a16bc-2341-40f5-aa56-d8d4583741aa",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/verbose.cpp"
                },
                "region": {
                  "startLine": 101,
                  "startColumn": 8,
                  "endLine": 101,
                  "endColumn": 14,
                  "charOffset": 2984,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b36c68f0-71d1-45ad-9eab-f0adfda4c252",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/verbose.cpp"
                },
                "region": {
                  "startLine": 97,
                  "startColumn": 8,
                  "endLine": 97,
                  "endColumn": 14,
                  "charOffset": 2739,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-9655f16d-ba55-49be-a959-1dda7c9a13b9",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/cpu_isa_traits.cpp"
                },
                "region": {
                  "startLine": 249,
                  "startColumn": 15,
                  "endLine": 249,
                  "endColumn": 18,
                  "charOffset": 8250,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-61282d35-9a4c-4ba4-908f-a1ebae76ed6d",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/cpu_isa_traits.cpp"
                },
                "region": {
                  "startLine": 247,
                  "startColumn": 28,
                  "endLine": 247,
                  "endColumn": 31,
                  "charOffset": 8167,
                  "charLength": 3,
                  "snippet": {
                    "text": "EAX",
                    "rendered": {
                      "text": "EAX",
                      "markdown": "`EAX`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-8e4ea937-4173-484c-bce2-17c04d58646b",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/gemm_bf16_inner_product.hpp"
                },
                "region": {
                  "startLine": 246,
                  "startColumn": 37,
                  "endLine": 246,
                  "endColumn": 40,
                  "charOffset": 9631,
                  "charLength": 3,
                  "snippet": {
                    "text": "OCB",
                    "rendered": {
                      "text": "OCB",
                      "markdown": "`OCB`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-d780ab2f-38e0-473c-a9b2-c8391c37a43c",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/gemm_bf16_inner_product.hpp"
                },
                "region": {
                  "startLine": 243,
                  "startColumn": 49,
                  "endLine": 243,
                  "endColumn": 52,
                  "charOffset": 9506,
                  "charLength": 3,
                  "snippet": {
                    "text": "OCB",
                    "rendered": {
                      "text": "OCB",
                      "markdown": "`OCB`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-e0f2e97d-268f-4fa4-a366-d8f9f71904d9",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "A weak cipher mode of operation was used"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/gemm_bf16_inner_product.hpp"
                },
                "region": {
                  "startLine": 242,
                  "startColumn": 18,
                  "endLine": 242,
                  "endColumn": 21,
                  "charOffset": 9416,
                  "charLength": 3,
                  "snippet": {
                    "text": "OCB",
                    "rendered": {
                      "text": "OCB",
                      "markdown": "`OCB`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-131b32cb-76bf-4ef1-8473-ceeada41bca5",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Weak/Broken Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/verbose.cpp"
                },
                "region": {
                  "startLine": 256,
                  "startColumn": 12,
                  "endLine": 256,
                  "endColumn": 15,
                  "charOffset": 7339,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7339,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/verbose.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7339,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "glog-e4d7fc90-a038-4220-91a6-a58271353521",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/verbose.cpp"
                },
                "region": {
                  "startLine": 107,
                  "startColumn": 8,
                  "endLine": 107,
                  "endColumn": 14,
                  "charOffset": 3260,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-71c77052-aeea-4646-ba96-f5eb518a835a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/verbose.cpp"
                },
                "region": {
                  "startLine": 104,
                  "startColumn": 8,
                  "endLine": 104,
                  "endColumn": 14,
                  "charOffset": 3155,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-6132b22f-a970-44f4-acbf-d9f4875c7725",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/zendnn_grp_ebag_matmul.cpp"
                },
                "region": {
                  "startLine": 141,
                  "startColumn": 8,
                  "endLine": 141,
                  "endColumn": 59,
                  "charOffset": 5229,
                  "charLength": 51,
                  "snippet": {
                    "text": "memcpy(hndl, bias_hndl, result_size * sizeof(float)",
                    "rendered": {
                      "text": "memcpy(hndl, bias_hndl, result_size * sizeof(float)",
                      "markdown": "`memcpy(hndl, bias_hndl, result_size * sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/zendnn_grp_ebag_matmul.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5229,
                        "charLength": 51
                      },
                      "insertedContent": {
                        "text": "memcpy_s(hndl, <size of hndl>,  bias_hndl,  result_size * sizeof(float)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-99efb0ff-148e-4892-b496-389a0792bc51",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/zendnn_profiler.hpp"
                },
                "region": {
                  "startLine": 20,
                  "startColumn": 10,
                  "endLine": 20,
                  "endColumn": 15,
                  "charOffset": 861,
                  "charLength": 5,
                  "snippet": {
                    "text": "ctime",
                    "rendered": {
                      "text": "ctime",
                      "markdown": "`ctime`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1ae11b5f-e2be-487c-80a5-0197da2c16f3",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/zendnn_utils.hpp"
                },
                "region": {
                  "startLine": 173,
                  "startColumn": 45,
                  "endLine": 174,
                  "endColumn": 45,
                  "charOffset": 6255,
                  "charLength": 81,
                  "snippet": {
                    "text": "malloc(zenLibBufPoolLimit * sizeof(\n                               zenLibBufPool)",
                    "rendered": {
                      "text": "malloc(zenLibBufPoolLimit * sizeof(\n                               zenLibBufPool)",
                      "markdown": "`malloc(zenLibBufPoolLimit * sizeof(\n                               zenLibBufPool)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/zendnn_utils.hpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6255,
                        "charLength": 81
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-44e0cf9d-5c4e-479b-bbc9-ae411866f2a2",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/utils.hpp"
                },
                "region": {
                  "startLine": 612,
                  "startColumn": 6,
                  "endLine": 612,
                  "endColumn": 11,
                  "charOffset": 18890,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-76b6332e-125a-4b36-b5d8-7708b5e4f793",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/utils.hpp"
                },
                "region": {
                  "startLine": 596,
                  "startColumn": 4,
                  "endLine": 596,
                  "endColumn": 10,
                  "charOffset": 18093,
                  "charLength": 6,
                  "snippet": {
                    "text": "getenv",
                    "rendered": {
                      "text": "getenv",
                      "markdown": "`getenv`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ff584fc7-6755-4a7e-adab-32392a242bbc",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/zendnn_convolution_direct.cpp"
                },
                "region": {
                  "startLine": 72,
                  "startColumn": 4,
                  "endLine": 72,
                  "endColumn": 10,
                  "charOffset": 2527,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-94a548eb-8a35-4d5e-893c-55eff9cce038",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/zendnn_utils.cpp"
                },
                "region": {
                  "startLine": 731,
                  "startColumn": 16,
                  "endLine": 731,
                  "endColumn": 28,
                  "charOffset": 30501,
                  "charLength": 12,
                  "snippet": {
                    "text": "malloc(size)",
                    "rendered": {
                      "text": "malloc(size)",
                      "markdown": "`malloc(size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/zendnn_utils.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 30501,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-28bd4bc9-d445-4f85-bd8b-7962f5d49be3",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/zendnn_utils.cpp"
                },
                "region": {
                  "startLine": 711,
                  "startColumn": 31,
                  "endLine": 711,
                  "endColumn": 51,
                  "charOffset": 30086,
                  "charLength": 20,
                  "snippet": {
                    "text": "malloc(sizeof(float)",
                    "rendered": {
                      "text": "malloc(sizeof(float)",
                      "markdown": "`malloc(sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/zendnn_utils.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 30086,
                        "charLength": 20
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-3a4db3dc-6b86-43bf-baaf-8fc4dc97e787",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/gemm/f32/jit_avx_gemm_f32.cpp"
                },
                "region": {
                  "startLine": 2411,
                  "startColumn": 29,
                  "endLine": 2412,
                  "endColumn": 34,
                  "charOffset": 89683,
                  "charLength": 42,
                  "snippet": {
                    "text": "malloc(\n                sizeof(*c_buffers)",
                    "rendered": {
                      "text": "malloc(\n                sizeof(*c_buffers)",
                      "markdown": "`malloc(\n                sizeof(*c_buffers)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/cpu/x64/gemm/f32/jit_avx_gemm_f32.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 89683,
                        "charLength": 42
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-4d213a9d-d0ea-49e0-8928-6963371b5cc4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/bit_cast.hpp"
                },
                "region": {
                  "startLine": 47,
                  "startColumn": 9,
                  "endLine": 47,
                  "endColumn": 33,
                  "charOffset": 1772,
                  "charLength": 24,
                  "snippet": {
                    "text": "memcpy(&t, &u, sizeof(U)",
                    "rendered": {
                      "text": "memcpy(&t, &u, sizeof(U)",
                      "markdown": "`memcpy(&t, &u, sizeof(U)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/bit_cast.hpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1772,
                        "charLength": 24
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&t, <size of &t>,  &u,  sizeof(U)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-53356af0-3b96-40ad-946f-ebdca1e93b58",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/x64/gemm/f32/jit_avx512_common_gemm_f32.cpp"
                },
                "region": {
                  "startLine": 1777,
                  "startColumn": 29,
                  "endLine": 1778,
                  "endColumn": 34,
                  "charOffset": 67133,
                  "charLength": 42,
                  "snippet": {
                    "text": "malloc(\n                sizeof(*c_buffers)",
                    "rendered": {
                      "text": "malloc(\n                sizeof(*c_buffers)",
                      "markdown": "`malloc(\n                sizeof(*c_buffers)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/cpu/x64/gemm/f32/jit_avx512_common_gemm_f32.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 67133,
                        "charLength": 42
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b4ef34bb-2ff4-4127-a0a7-e17843081c42",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/zendnn_utils.cpp"
                },
                "region": {
                  "startLine": 683,
                  "startColumn": 24,
                  "endLine": 684,
                  "endColumn": 44,
                  "charOffset": 29183,
                  "charLength": 101,
                  "snippet": {
                    "text": "memcpy(col_data, input_data + (ih * width + iw) * depth,\n                               sizeof(float)",
                    "rendered": {
                      "text": "memcpy(col_data, input_data + (ih * width + iw) * depth,\n                               sizeof(float)",
                      "markdown": "`memcpy(col_data, input_data + (ih * width + iw) * depth,\n                               sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/zendnn_utils.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29183,
                        "charLength": 101
                      },
                      "insertedContent": {
                        "text": "memcpy_s(col_data, <size of col_data>,  input_data + (ih * width + iw) * depth, \n                               sizeof(float)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f4bc3d51-7633-4b31-a319-71d359223f12",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/zendnn_utils.cpp"
                },
                "region": {
                  "startLine": 40,
                  "startColumn": 4,
                  "endLine": 40,
                  "endColumn": 53,
                  "charOffset": 1456,
                  "charLength": 49,
                  "snippet": {
                    "text": "memcpy(&float_value, &inter_temp, sizeof(int32_t)",
                    "rendered": {
                      "text": "memcpy(&float_value, &inter_temp, sizeof(int32_t)",
                      "markdown": "`memcpy(&float_value, &inter_temp, sizeof(int32_t)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/zendnn_utils.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1456,
                        "charLength": 49
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&float_value, <size of &float_value>,  &inter_temp,  sizeof(int32_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ea2f3f58-ab1d-4867-be0e-dabc189f916d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/zendnn_matmul_int8.cpp"
                },
                "region": {
                  "startLine": 602,
                  "startColumn": 51,
                  "endLine": 603,
                  "endColumn": 51,
                  "charOffset": 26080,
                  "charLength": 66,
                  "snippet": {
                    "text": "malloc(sizeof(\n                                 aocl_post_op_bias)",
                    "rendered": {
                      "text": "malloc(sizeof(\n                                 aocl_post_op_bias)",
                      "markdown": "`malloc(sizeof(\n                                 aocl_post_op_bias)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/zendnn_matmul_int8.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 26080,
                        "charLength": 66
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-9c8d4c5d-ae78-4d4e-bdb1-3a446b444943",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/zendnn_utils.cpp"
                },
                "region": {
                  "startLine": 33,
                  "startColumn": 4,
                  "endLine": 33,
                  "endColumn": 65,
                  "charOffset": 1230,
                  "charLength": 61,
                  "snippet": {
                    "text": "memcpy((bf16_val), (char *)(float_value) + 2, sizeof(int16_t)",
                    "rendered": {
                      "text": "memcpy((bf16_val), (char *)(float_value) + 2, sizeof(int16_t)",
                      "markdown": "`memcpy((bf16_val), (char *)(float_value) + 2, sizeof(int16_t)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/zendnn_utils.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1230,
                        "charLength": 61
                      },
                      "insertedContent": {
                        "text": "memcpy_s((bf16_val), <size of (bf16_val)>,  (char *)(float_value) + 2,  sizeof(int16_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d6960acb-316b-410f-a7d3-e929a975ef59",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/zendnn_matmul_int8.cpp"
                },
                "region": {
                  "startLine": 590,
                  "startColumn": 57,
                  "endLine": 591,
                  "endColumn": 57,
                  "charOffset": 25509,
                  "charLength": 72,
                  "snippet": {
                    "text": "malloc(sizeof(\n                                    aocl_post_op_eltwise)",
                    "rendered": {
                      "text": "malloc(sizeof(\n                                    aocl_post_op_eltwise)",
                      "markdown": "`malloc(sizeof(\n                                    aocl_post_op_eltwise)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/zendnn_matmul_int8.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 25509,
                        "charLength": 72
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-127a595e-2e67-4b3a-957d-10a008b8878a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/zendnn_matmul_int8.cpp"
                },
                "region": {
                  "startLine": 543,
                  "startColumn": 53,
                  "endLine": 544,
                  "endColumn": 56,
                  "charOffset": 23911,
                  "charLength": 89,
                  "snippet": {
                    "text": "malloc(max_post_ops_seq_length *\n                               sizeof(AOCL_POST_OP_TYPE)",
                    "rendered": {
                      "text": "malloc(max_post_ops_seq_length *\n                               sizeof(AOCL_POST_OP_TYPE)",
                      "markdown": "`malloc(max_post_ops_seq_length *\n                               sizeof(AOCL_POST_OP_TYPE)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/zendnn_matmul_int8.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 23911,
                        "charLength": 89
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-36458468-0840-4a65-a943-a4e68d82c670",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/zendnn_matmul_int8.cpp"
                },
                "region": {
                  "startLine": 598,
                  "startColumn": 63,
                  "endLine": 599,
                  "endColumn": 63,
                  "charOffset": 25901,
                  "charLength": 78,
                  "snippet": {
                    "text": "malloc(sizeof(\n                                       aocl_post_op_matrix_mul)",
                    "rendered": {
                      "text": "malloc(sizeof(\n                                       aocl_post_op_matrix_mul)",
                      "markdown": "`malloc(sizeof(\n                                       aocl_post_op_matrix_mul)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/zendnn_matmul_int8.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 25901,
                        "charLength": 78
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-6b9d4e7f-1bfc-421f-8eb4-b3e6b3207fde",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/zendnn_matmul_int8.cpp"
                },
                "region": {
                  "startLine": 629,
                  "startColumn": 45,
                  "endLine": 629,
                  "endColumn": 66,
                  "charOffset": 27440,
                  "charLength": 21,
                  "snippet": {
                    "text": "malloc(scale_zp_size)",
                    "rendered": {
                      "text": "malloc(scale_zp_size)",
                      "markdown": "`malloc(scale_zp_size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/zendnn_matmul_int8.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 27440,
                        "charLength": 21
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-911932c6-bb03-4ba1-9a79-feba4789cb9c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/zendnn_matmul_int8.cpp"
                },
                "region": {
                  "startLine": 594,
                  "startColumn": 63,
                  "endLine": 595,
                  "endColumn": 63,
                  "charOffset": 25702,
                  "charLength": 78,
                  "snippet": {
                    "text": "malloc(sizeof(\n                                       aocl_post_op_matrix_add)",
                    "rendered": {
                      "text": "malloc(sizeof(\n                                       aocl_post_op_matrix_add)",
                      "markdown": "`malloc(sizeof(\n                                       aocl_post_op_matrix_add)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/zendnn_matmul_int8.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 25702,
                        "charLength": 78
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-2d2edb79-c086-4129-bf1b-61e9d4d43737",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/zendnn_matmul_int8.cpp"
                },
                "region": {
                  "startLine": 541,
                  "startColumn": 36,
                  "endLine": 541,
                  "endColumn": 63,
                  "charOffset": 23763,
                  "charLength": 27,
                  "snippet": {
                    "text": "malloc(sizeof(aocl_post_op)",
                    "rendered": {
                      "text": "malloc(sizeof(aocl_post_op)",
                      "markdown": "`malloc(sizeof(aocl_post_op)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/zendnn_matmul_int8.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 23763,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-dc7fb73c-6045-4fd2-9d1d-56dc7b677766",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/rnn/ref_postgemm_lstm_projection.cpp"
                },
                "region": {
                  "startLine": 60,
                  "startColumn": 21,
                  "endLine": 61,
                  "endColumn": 66,
                  "charOffset": 2346,
                  "charLength": 102,
                  "snippet": {
                    "text": "memcpy(dst_iter_ + i * dst_iter_ld,\n                        dst_layer_ + i * dst_layer_ld, block_step)",
                    "rendered": {
                      "text": "memcpy(dst_iter_ + i * dst_iter_ld,\n                        dst_layer_ + i * dst_layer_ld, block_step)",
                      "markdown": "`memcpy(dst_iter_ + i * dst_iter_ld,\n                        dst_layer_ + i * dst_layer_ld, block_step)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/cpu/rnn/ref_postgemm_lstm_projection.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2346,
                        "charLength": 102
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst_iter_ + i * dst_iter_ld, <size of dst_iter_ + i * dst_iter_ld>, \n                        dst_layer_ + i * dst_layer_ld,  block_step)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-8e067d85-ae52-4a0a-9bb0-eddaef788b69",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/cpu/rnn/ref_postgemm_lstm_projection.cpp"
                },
                "region": {
                  "startLine": 56,
                  "startColumn": 21,
                  "endLine": 57,
                  "endColumn": 66,
                  "charOffset": 2157,
                  "charLength": 102,
                  "snippet": {
                    "text": "memcpy(dst_iter_ + i * dst_iter_ld,\n                        dst_layer_ + i * dst_layer_ld, block_step)",
                    "rendered": {
                      "text": "memcpy(dst_iter_ + i * dst_iter_ld,\n                        dst_layer_ + i * dst_layer_ld, block_step)",
                      "markdown": "`memcpy(dst_iter_ + i * dst_iter_ld,\n                        dst_layer_ + i * dst_layer_ld, block_step)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/cpu/rnn/ref_postgemm_lstm_projection.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2157,
                        "charLength": 102
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dst_iter_ + i * dst_iter_ld, <size of dst_iter_ + i * dst_iter_ld>, \n                        dst_layer_ + i * dst_layer_ld,  block_step)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5adbc8aa-bfd8-4c33-8f19-cef70c44d2b3",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/zendnn_matmul_woq.cpp"
                },
                "region": {
                  "startLine": 895,
                  "startColumn": 55,
                  "endLine": 895,
                  "endColumn": 84,
                  "charOffset": 37566,
                  "charLength": 29,
                  "snippet": {
                    "text": "malloc(sizeof(aocl_pre_op_sf)",
                    "rendered": {
                      "text": "malloc(sizeof(aocl_pre_op_sf)",
                      "markdown": "`malloc(sizeof(aocl_pre_op_sf)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/zendnn_matmul_woq.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 37566,
                        "charLength": 29
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-af5ef9b5-3c8f-4188-819d-6561afdfef40",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/nstl.hpp"
                },
                "region": {
                  "startLine": 51,
                  "startColumn": 34,
                  "endLine": 51,
                  "endColumn": 46,
                  "charOffset": 1828,
                  "charLength": 12,
                  "snippet": {
                    "text": "malloc(size)",
                    "rendered": {
                      "text": "malloc(size)",
                      "markdown": "`malloc(size)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/nstl.hpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1828,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-7464485c-1996-4cef-81f8-9edd52cf702f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/zendnn_matmul_woq.cpp"
                },
                "region": {
                  "startLine": 848,
                  "startColumn": 55,
                  "endLine": 848,
                  "endColumn": 84,
                  "charOffset": 35335,
                  "charLength": 29,
                  "snippet": {
                    "text": "malloc(sizeof(aocl_pre_op_sf)",
                    "rendered": {
                      "text": "malloc(sizeof(aocl_pre_op_sf)",
                      "markdown": "`malloc(sizeof(aocl_pre_op_sf)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/zendnn_matmul_woq.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 35335,
                        "charLength": 29
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-caf7406e-66fc-40ae-8eac-20a2d55b486d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/zendnn_matmul_woq.cpp"
                },
                "region": {
                  "startLine": 893,
                  "startColumn": 43,
                  "endLine": 893,
                  "endColumn": 69,
                  "charOffset": 37396,
                  "charLength": 26,
                  "snippet": {
                    "text": "malloc(sizeof(aocl_pre_op)",
                    "rendered": {
                      "text": "malloc(sizeof(aocl_pre_op)",
                      "markdown": "`malloc(sizeof(aocl_pre_op)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/zendnn_matmul_woq.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 37396,
                        "charLength": 26
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-14df1c41-c489-4d47-8cdd-0e261fa239de",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/common/zendnn_matmul_woq.cpp"
                },
                "region": {
                  "startLine": 277,
                  "startColumn": 70,
                  "endLine": 277,
                  "endColumn": 90,
                  "charOffset": 11604,
                  "charLength": 20,
                  "snippet": {
                    "text": "malloc(sizeof(float)",
                    "rendered": {
                      "text": "malloc(sizeof(float)",
                      "markdown": "`malloc(sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/common/zendnn_matmul_woq.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11604,
                        "charLength": 20
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}